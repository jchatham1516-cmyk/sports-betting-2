# -*- coding: utf-8 -*-
"""Current of sports betting algorithm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qb3_A8RdpuekDv9e3airJ1CQVIehiiuT
"""

from nba_api.stats.library.parameters import *

endpoint_list  [
    "2AssistTracker",
    "AllPlayers",
    "AllStarBallotPredictor",
    "AllTimeLeadersGrids",
    "AssistLeaders",
    "AssistTracker",
    "AssistTrackerStats",
    "BoxScoreAdvanced",
    "BoxScoreAdvancedV2",
    "BoxScoreDefensiveV2",
    "BoxScoreFourFactors",
    "BoxScoreFourFactorsV2",
    "BoxScoreMatchupsV3",
    "BoxScoreMisc",
    "BoxScoreMiscV2",
    "BoxScorePlayerTracking",
    "BoxScoreScoring",
    "BoxScoreScoringV2",
    "BoxScoreSummary",
    "BoxScoreSummaryV2",
    "BoxScoreTraditional",
    "BoxScoreTraditionalV2",
    "BoxScoreUsage",
    "BoxScoreUsageV2",
    "CommonAllPlayers",
    "CommonPlayerInfo",
    "CommonPlayoffSeries",
    "CommonTeamRoster",
    "CommonTeamYears",
    "CumeStatsPlayer",
    "CumeStatsPlayerGames",
    "CumeStatsTeam",
    "CumeStatsTeamGames",
    "DefenseHub",
    "DLeaguePredictor",
    "DraftBoard",
    "DraftCombineDrillResults",
    "DraftCombineNonStationaryShooting",
    "DraftCombinePlayerAnthro",
    "DraftCombinePlayerMeasurements",
    "DraftCombineSpotShooting",
    "DraftCombineStats",
    "DraftHistory",
    "FantasyWidget",
    "FranchiseHistory",
    "FranchiseLeaders",
    "FranchisePlayers",
    "GameRotation",
    "GLAlumBoxScoreSimilarityScore",
    "GLeaguePredictor",
    "HomePage",
    "HomePageLeaders",
    "HomePageV2",
    "HustleStatsBoxScore",
    "InfographicFanDuelPlayer",
    "ISTStandings",
    "LeadersTiles",
    "LeagueDashLineups",
    "LeagueDashOppPtShot",
    "LeagueDashPlayerBioStats",
    "LeagueDashPlayerClutch",
    "LeagueDashPlayerPtShot",
    "LeagueDashPlayerShotLocations",
    "LeagueDashPlayerStats",
    "LeagueDashPtDefend",
    "LeagueDashPtStats",
    "LeagueDashPtTeamDefend",
    "LeagueDashTeamClutch",
    "LeagueDashTeamPtShot",
    "LeagueDashTeamShotLocations",
    "LeagueDashTeamStats",
    "LeagueGameFinder",
    "LeagueGameLog",
    "LeagueHustleStatsPlayer",
    "LeagueHustleStatsTeam",
    "LeagueLeaders",
    "LeagueLineupViz",
    "LeaguePlayerOnDetails",
    "LeagueSeasonMatchups",
    "LeagueStandings",
    "LeagueStandingsV3",
    "LineupStats",
    "MatchupsRollup",
    "PlayByPlay",
    "PlayByPlayMini",
    "PlayByPlayV2",
    "PlayerAwards",
    "PlayerBioStats",
    "PlayerCareerByCollege",
    "PlayerCareerByCollegeRollup",
    "PlayerCareerStats",
    "PlayerClutchStats",
    "PlayerCompare",
    "PlayerCompareStats",
    "PlayerDashboardByClutch",
    "PlayerDashboardByGameSplits",
    "PlayerDashboardByGeneralSplits",
    "PlayerDashboardByLastNGames",
    "PlayerDashboardByShootingSplits",
    "PlayerDashboardByTeamPerformance",
    "PlayerDashboardByYearOverYear",
    "PlayerDashPtPass",
    "PlayerDashPtReb",
    "PlayerDashPtReboundLogs",
    "PlayerDashPtShotDefend",
    "PlayerDashPtShotlog",
    "PlayerDashPtShots",
    "PlayerDefenseStats",
    "PlayerEstimatedMetrics",
    "PlayerFantasyProfileBarGraph",
    "PlayerGameLog",
    "PlayerGameLogs",
    "PlayerGameLogsStats",
    "PlayerGameSplitsStats",
    "PlayerGameStreakFinder",
    "PlayerGeneralSplitsStats",
    "PlayerInfo",
    "PlayerIndex",
    "PlayerLastNGamesStats",
    "PlayerNextNGames",
    "PlayerOnDetails",
    "PlayerOpponentStats",
    "PlayerPassesStats",
    "PlayerProfile",
    "PlayerProfileV2",
    "PlayerReboundsStats",
    "PlayersCareerStats",
    "PlayersClutchStats",
    "PlayersDefenseStats",
    "PlayersGeneralStats",
    "PlayerShotChartDetail",
    "PlayerShotsStats",
    "PlayersHustleLeaders",
    "PlayersHustleStats",
    "PlayersShotLocationStats",
    "PlayersShotStats",
    "PlayersTrackingStats",
    "PlayersVsPlayers",
    "PlayerTeamPerformanceStats",
    "PlayerTrackBucketSimilarityScore",
    "PlayerTrackRankSimilarityComp",
    "PlayerTrackSimilarityScore",
    "PlayerTrackSimilarityUniqueness",
    "PlayerVsPlayer",
    "PlayerYearOverYearStats",
    "PlayoffPicture",
    "PlayoffSeries",
    "ScheduleLeagueV2",
    "ScheduleLeagueV2Int",
    "Scoreboard",
    "ScoreboardMini",
    "ScoreboardV2",
    "ShotChartDetail",
    "ShotChartLeagueWide",
    "ShotChartLineupDetail",
    "SynergyBucketSimilarityScore",
    "SynergyPlayTypes",
    "SynergySimilarityScore",
    "TeamAndPlayerVsPlayers",
    "TeamAndPlayersVsPlayers",
    "TeamClutchStats",
    "TeamDashboardByGeneralSplits",
    "TeamDashboardByShootingSplits",
    "TeamDashLineups",
    "TeamDashPtPass",
    "TeamDashPtReb",
    "TeamDashPtShots",
    "TeamDetails",
    "TeamEstimatedMetrics",
    "TeamFranchiseLeaders",
    "TeamFranchiseLeadersRank",
    "TeamGameSplitsStats",
    "TeamGameStreakFinder",
    "TeamGeneralSplitsStats",
    "TeamHistoricalLeaders",
    "TeamInfo",
    "TeamInfoCommon",
    "TeamLastNGamesStats",
    "TeamLineupStats",
    "TeamOpponentStats",
    "TeamPassesStats",
    "TeamPerformanceStats",
    "TeamPlayerDashboard",
    "TeamPlayerOnOffDetails",
    "TeamPlayerOnOffSummary",
    "TeamPlayerStats",
    "TeamReboundsStats",
    "TeamRoster",
    "TeamsClutchStats",
    "TeamsDefenseStats",
    "TeamsGeneralStats",
    "TeamShootingSplitsStats",
    "TeamShotChartLineupDetail",
    "TeamShotsStats",
    "TeamsHustleLeaders",
    "TeamsHustleStats",
    "TeamsShotLocationStats",
    "TeamsShotStats",
    "TeamsYearByYearStats",
    "TeamVsPlayer",
    "TeamYearByYearStats",
    "TeamYearOverYearStats",
    "TeamYears",
    "VideoDetails",
    "VideoDetailsAsset",
    "VideoEvents",
    "VideoStatus",
    "WinProbabilityPlayByPlay",
    "WinProbabilityPBP",
]

parameter_variations  {
    "GameEventID": {
        "default_py_value": "0",
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "GameID": {
        "default_py_value": None,
        "parameter_value": "0021700807",  # CLE vs MIN - 2018-02-07
        "parameter_error_value": "a",
    },
    "GameIDs": {
        "default_py_value": None,
        "parameter_value": "0021700807",  # CLE vs MIN - 2018-02-07
        "parameter_error_value": "a",
    },
    "GameIDNullable": {
        "default_py_value": "''",
        "parameter_value": None,
        "parameter_error_value": "a",
    },
    "Person1LeagueID": {
        "default_py_value": "LeagueID.default",
        "parameter_value": LeagueID.default,
        "parameter_error_value": "a",
    },
    "Person2LeagueID": {
        "default_py_value": "LeagueID.default",
        "parameter_value": LeagueID.default,
        "parameter_error_value": "a",
    },
    "LeagueID": {
        "default_py_value": "LeagueID.default",
        "parameter_value": LeagueID.default,
        "parameter_error_value": "a",
    },
    "LeagueIDNullable": {
        "default_py_value": "LeagueIDNullable.default",
        "parameter_value": LeagueIDNullable.default,
        "parameter_error_value": "a",
    },
    "Active": {
        "default_py_value": "Active.default",
        "parameter_value": Active.default,
        "parameter_error_value": 0,
    },
    "ActiveNullable": {
        "default_py_value": "ActiveNullable.default",
        "parameter_value": ActiveNullable.default,
        "parameter_error_value": 0,
    },
    "ActiveFlagNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "AheadBehind": {
        "default_py_value": "AheadBehind.default",
        "parameter_value": AheadBehind.default,
        "parameter_error_value": 0,
    },
    "AheadBehindNullable": {
        "default_py_value": "AheadBehindNullable.default",
        "parameter_value": AheadBehindNullable.default,
        "parameter_error_value": 0,
    },
    "AllStar": {
        "default_py_value": "AllStar.default",
        "parameter_value": AllStar.default,
        "parameter_error_value": 0,
    },
    "AllStarNullable": {
        "default_py_value": "AllStarNullable.default",
        "parameter_value": AllStarNullable.default,
        "parameter_error_value": 0,
    },
    "CloseDefDistRangeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "ClutchTime": {
        "default_py_value": "ClutchTime.default",
        "parameter_value": ClutchTime.default,
        "parameter_error_value": 0,
    },
    "ClutchTimeNullable": {
        "default_py_value": "ClutchTimeNullable.default",
        "parameter_value": ClutchTimeNullable.default,
        "parameter_error_value": 0,
    },
    "College": {
        "default_py_value": None,
        "parameter_value": "Ohio State",
        "parameter_error_value": 1,
    },
    "CollegeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "Conference": {
        "default_py_value": "Conference.default",
        "parameter_value": Conference.default,
        "parameter_error_value": 0,
    },
    "ConferenceNullable": {
        "default_py_value": "ConferenceNullable.default",
        "parameter_value": ConferenceNullable.default,
        "parameter_error_value": 0,
    },
    "VsConference": {
        "default_py_value": "Conference.default",
        "parameter_value": Conference.default,
        "parameter_error_value": 0,
    },
    "VsConferenceNullable": {
        "default_py_value": "ConferenceNullable.default",
        "parameter_value": ConferenceNullable.default,
        "parameter_error_value": 0,
    },
    "ContextFilterNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "ContextMeasureSimple": {
        "default_py_value": "ContextMeasureSimple.default",
        "parameter_value": ContextMeasureSimple.default,
        "parameter_error_value": 0,
    },
    "ContextMeasureSimpleNullable": {
        "default_py_value": "ContextMeasureSimpleNullable.default",
        "parameter_value": ContextMeasureSimpleNullable.default,
        "parameter_error_value": 0,
    },
    "ContextMeasureDetailed": {
        "default_py_value": "ContextMeasureDetailed.default",
        "parameter_value": ContextMeasureDetailed.default,
        "parameter_error_value": 0,
    },
    "Counter": {
        "default_py_value": "0",
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "CounterNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "CountryNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DateFromNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DateToNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DayOffset": {
        "default_py_value": "DayOffset.default",
        "parameter_value": DayOffset.default,
        "parameter_error_value": "a",
    },
    "DefenseCategory": {
        "default_py_value": "DefenseCategory.default",
        "parameter_value": DefenseCategory.default,
        "parameter_error_value": 0,
    },
    "DefenseCategoryNullable": {
        "default_py_value": "DefenseCategoryNullable.default",
        "parameter_value": DefenseCategoryNullable.default,
        "parameter_error_value": 0,
    },
    "Direction": {
        "default_py_value": "Direction.default",
        "parameter_value": Direction.default,
        "parameter_error_value": 0,
    },
    "DistanceRange": {
        "default_py_value": "DistanceRange.default",
        "parameter_value": DistanceRange.default,
        "parameter_error_value": 0,
    },
    "DivisionSimple": {
        "default_py_value": "DivisionSimple.default",
        "parameter_value": DivisionSimple.default,
        "parameter_error_value": 0,
    },
    "DivisionSimpleNullable": {
        "default_py_value": "DivisionSimpleNullable.default",
        "parameter_value": DivisionSimpleNullable.default,
        "parameter_error_value": 0,
    },
    "Division": {
        "default_py_value": "Division.default",
        "parameter_value": Division.default,
        "parameter_error_value": 0,
    },
    "DivisionNullable": {
        "default_py_value": "DivisionNullable.default",
        "parameter_value": DivisionNullable.default,
        "parameter_error_value": 0,
    },
    "VsDivision": {
        "default_py_value": "Division.default",
        "parameter_value": Division.default,
        "parameter_error_value": 0,
    },
    "VsDivisionNullable": {
        "default_py_value": "DivisionNullable.default",
        "parameter_value": DivisionNullable.default,
        "parameter_error_value": 0,
    },
    "DraftPickNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DraftYearNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DribbleRangeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GameDate": {
        "default_py_value": "GameDate.default",
        "parameter_value": GameDate.default,
        "parameter_error_value": "a",
    },
    "GameScopeSimple": {
        "default_py_value": "GameScopeSimple.default",
        "parameter_value": GameScopeSimple.default,
        "parameter_error_value": 0,
    },
    "GameScopeSimpleNullable": {
        "default_py_value": "GameScopeSimpleNullable.default",
        "parameter_value": GameScopeSimpleNullable.default,
        "parameter_error_value": 0,
    },
    "GameScopeDetailed": {
        "default_py_value": "GameScopeDetailed.default",
        "parameter_value": GameScopeDetailed.default,
        "parameter_error_value": 0,
    },
    "GameSegment": {
        "default_py_value": "GameSegment.default",
        "parameter_value": GameSegment.default,
        "parameter_error_value": "234",
    },
    "GameSegmentNullable": {
        "default_py_value": "GameSegmentNullable.default",
        "parameter_value": GameSegmentNullable.default,
        "parameter_error_value": "234",
    },
    "GeneralRangeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GraphStatNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GroupQuantity": {
        "default_py_value": "GroupQuantity.default",
        "parameter_value": GroupQuantity.default,
        "parameter_error_value": "a",
    },
    "GroupID": {
        "default_py_value": "0",
        "parameter_value": 0,
        "parameter_error_value": "a",
    },
    "HeightNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "Historical": {
        "default_py_value": "Historical.default",
        "parameter_value": Historical.default,
        "parameter_error_value": 0,
    },
    "HistoricalNullable": {
        "default_py_value": "HistoricalNullable.default",
        "parameter_value": HistoricalNullable.default,
        "parameter_error_value": 0,
    },
    "LastNGames": {
        "default_py_value": "LastNGames.default",
        "parameter_value": LastNGames.default,
        "parameter_error_value": "a",
    },
    "LastNGamesNullable": {
        "default_py_value": "LastNGamesNullable.default",
        "parameter_value": LastNGamesNullable.default,
        "parameter_error_value": "a",
    },
    "Location": {
        "default_py_value": "Location.default",
        "parameter_value": Location.default,
        "parameter_error_value": 0,
    },
    "LocationNullable": {
        "default_py_value": "LocationNullable.default",
        "parameter_value": LocationNullable.default,
        "parameter_error_value": 0,
    },
    "Month": {
        "default_py_value": "Month.default",
        "parameter_value": Month.default,
        "parameter_error_value": "a",
    },
    "MonthNullable": {
        "default_py_value": "MonthNullable.default",
        "parameter_value": MonthNullable.default,
        "parameter_error_value": "a",
    },
    "MeasureTypeBase": {
        "default_py_value": "MeasureTypeBase.default",
        "parameter_value": MeasureTypeBase.default,
        "parameter_error_value": 0,
    },
    "MeasureTypeSimple": {
        "default_py_value": "MeasureTypeSimple.default",
        "parameter_value": MeasureTypeSimple.default,
        "parameter_error_value": 0,
    },
    "MeasureTypeDetailed": {
        "default_py_value": "MeasureTypeDetailed.default",
        "parameter_value": MeasureTypeDetailed.default,
        "parameter_error_value": 0,
    },
    "MeasureTypeDetailedDefense": {
        "default_py_value": "MeasureTypeDetailedDefense.default",
        "parameter_value": MeasureTypeDetailedDefense.default,
        "parameter_error_value": 0,
    },
    "MeasureTypePlayerGameLogsNullable": {
        "default_py_value": None,
        "parameter_value": "",
        "parameter_error_value": 0,
    },
    "NumberOfGames": {
        "default_py_value": "NumberOfGames.default",
        "parameter_value": NumberOfGames.default,
        "parameter_error_value": 0,
    },
    "Outcome": {
        "default_py_value": "Outcome.default",
        "parameter_value": Outcome.default,
        "parameter_error_value": 0,
    },
    "OutcomeNullable": {
        "default_py_value": "OutcomeNullable.default",
        "parameter_value": OutcomeNullable.default,
        "parameter_error_value": 0,
    },
    "OverallPickNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "PaceAdjust": {
        "default_py_value": "PaceAdjust.default",
        "parameter_value": PaceAdjust.default,
        "parameter_error_value": 0,
    },
    "PaceAdjustNo": {
        "default_py_value": "PaceAdjustNo.default",
        "parameter_value": PaceAdjustNo.default,
        "parameter_error_value": 0,
    },
    "PlusMinus": {
        "default_py_value": "PlusMinus.default",
        "parameter_value": PlusMinus.default,
        "parameter_error_value": 0,
    },
    "PlusMinusNo": {
        "default_py_value": "PlusMinusNo.default",
        "parameter_value": PlusMinusNo.default,
        "parameter_error_value": 0,
    },
    "Period": {
        "default_py_value": "Period.default",
        "parameter_value": Period.default,
        "parameter_error_value": "a",
    },
    "PeriodNullable": {
        "default_py_value": "PeriodNullable.default",
        "parameter_value": PeriodNullable.default,
        "parameter_error_value": "a",
    },
    "StartPeriod": {
        "default_py_value": "StartPeriod.default",
        "parameter_value": "1",
        "parameter_error_value": "a",
    },
    "StartPeriodNullable": {
        "default_py_value": "StartPeriodNullable.default",
        "parameter_value": StartPeriodNullable.default,
        "parameter_error_value": "a",
    },
    "EndPeriod": {
        "default_py_value": "EndPeriod.default",
        "parameter_value": "1",
        "parameter_error_value": "a",
    },
    "EndPeriodNullable": {
        "default_py_value": "EndPeriodNullable.default",
        "parameter_value": EndPeriodNullable.default,
        "parameter_error_value": "a",
    },
    "PerModeSimple": {
        "default_py_value": "PerModeSimple.default",
        "parameter_value": PerModeSimple.default,
        "parameter_error_value": 0,
    },
    "PerModeSimpleNullable": {
        "default_py_value": "PerModeSimpleNullable.default",
        "parameter_value": PerModeSimpleNullable.default,
        "parameter_error_value": 0,
    },
    "PerMode36": {
        "default_py_value": "PerMode36.default",
        "parameter_value": PerMode36.default,
        "parameter_error_value": 0,
    },
    "PerMode48": {
        "default_py_value": "PerMode48.default",
        "parameter_value": PerMode48.default,
        "parameter_error_value": 0,
    },
    "PerModeTime": {
        "default_py_value": "PerModeTime.default",
        "parameter_value": PerModeTime.default,
        "parameter_error_value": 0,
    },
    "PerModeDetailed": {
        "default_py_value": "PerModeDetailed.default",
        "parameter_value": PerModeDetailed.default,
        "parameter_error_value": 0,
    },
    "PlayerExperience": {
        "default_py_value": "PlayerExperience.default",
        "parameter_value": PlayerExperience.default,
        "parameter_error_value": 0,
    },
    "PlayerExperienceNullable": {
        "default_py_value": "PlayerExperienceNullable.default",
        "parameter_value": PlayerExperienceNullable.default,
        "parameter_error_value": 0,
    },
    "ActivePlayers": {
        "default_py_value": "ActivePlayers.default",
        "parameter_value": ActivePlayers.default,
        "parameter_error_value": "a",
    },
    "TodaysPlayers": {
        "default_py_value": "TodaysPlayers.default",
        "parameter_value": TodaysPlayers.default,
        "parameter_error_value": "a",
    },
    "PlayerID": {
        "default_py_value": None,
        "parameter_value": "2544",  # Lebron James
        "parameter_error_value": "a",
    },
    "PlayerIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",  # Lebron James
        "parameter_error_value": "a",
    },
    "DefPlayerIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "OffPlayerIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "VsPlayerID": {
        "default_py_value": None,
        "parameter_value": "2544",  # Lebron James
        "parameter_error_value": "a",
    },
    "Person1ID": {
        "default_py_value": None,
        "parameter_value": "202681",  # Kyrie Irving
        "parameter_error_value": "a",
    },
    "Person2ID": {
        "default_py_value": None,
        "parameter_value": "203078",  # Bradley Beal
        "parameter_error_value": "a",
    },
    "PlayerID1": {
        "default_py_value": None,
        "parameter_value": "202681",  # Kyrie Irving
        "parameter_error_value": "a",
    },
    "PlayerID2": {
        "default_py_value": None,
        "parameter_value": "203078",  # Bradley Beal
        "parameter_error_value": "a",
    },
    "PlayerID3": {
        "default_py_value": None,
        "parameter_value": "203507",  # Giannis Antetokounmpo
        "parameter_error_value": "a",
    },
    "PlayerID4": {
        "default_py_value": None,
        "parameter_value": "201567",  # Kevin Love
        "parameter_error_value": "a",
    },
    "PlayerID5": {
        "default_py_value": None,
        "parameter_value": "203954",  # Joel Embiid
        "parameter_error_value": "a",
    },
    "VsPlayerID1": {
        "default_py_value": None,
        "parameter_value": "201566",  # Russel Westbrook
        "parameter_error_value": "a",
    },
    "VsPlayerID2": {
        "default_py_value": None,
        "parameter_value": "201939",  # Stephen Curry
        "parameter_error_value": "a",
    },
    "VsPlayerID3": {
        "default_py_value": None,
        "parameter_value": "201935",  # James Harden
        "parameter_error_value": "a",
    },
    "VsPlayerID4": {
        "default_py_value": None,
        "parameter_value": "201142",  # Kevin Durant
        "parameter_error_value": "a",
    },
    "VsPlayerID5": {
        "default_py_value": None,
        "parameter_value": "203076",  # Anthony Davis
        "parameter_error_value": "a",
    },
    "EastPlayer1": {
        "default_py_value": None,
        "parameter_value": "202681",  # Kyrie Irving
        "parameter_error_value": "a",
    },
    "EastPlayer2": {
        "default_py_value": None,
        "parameter_value": "203078",  # Bradley Beal
        "parameter_error_value": "a",
    },
    "EastPlayer3": {
        "default_py_value": None,
        "parameter_value": "2544",  # Lebron James
        "parameter_error_value": "a",
    },
    "EastPlayer4": {
        "default_py_value": None,
        "parameter_value": "201567",  # Kevin Love
        "parameter_error_value": "a",
    },
    "EastPlayer5": {
        "default_py_value": None,
        "parameter_value": "203954",  # Joel Embiid
        "parameter_error_value": "a",
    },
    "WestPlayer1": {
        "default_py_value": None,
        "parameter_value": "201566",  # Russel Westbrook
        "parameter_error_value": "a",
    },
    "WestPlayer2": {
        "default_py_value": None,
        "parameter_value": "201939",  # Stephen Curry
        "parameter_error_value": "a",
    },
    "WestPlayer3": {
        "default_py_value": None,
        "parameter_value": "201935",  # James Harden
        "parameter_error_value": "a",
    },
    "WestPlayer4": {
        "default_py_value": None,
        "parameter_value": "201142",  # Kevin Durant
        "parameter_error_value": "a",
    },
    "WestPlayer5": {
        "default_py_value": None,
        "parameter_value": "203076",  # Anthony Davis
        "parameter_error_value": "a",
    },
    "PlayerIDList": {
        "default_py_value": None,
        "parameter_value": "202681,203078,2544,201567,203954",  # Kyrie Irving & Bradley Beal & Lebron James & Kevin Love & Joel Embiid
        "parameter_error_value": "a",
    },
    "VsPlayerIDList": {
        "default_py_value": None,
        # Russel Westbrook & Stephen Curry & James Harden & Kevin Durant & Anthony Davis
        "parameter_value": "201566,201939,201935,201142,203076",
        "parameter_error_value": "a",
    },
    "PlayerOrTeam": {
        "default_py_value": "PlayerOrTeam.default",
        "parameter_value": PlayerOrTeam.default,
        "parameter_error_value": 0,
    },
    "PlayerOrTeamAbbreviation": {
        "default_py_value": "PlayerOrTeamAbbreviation.default",
        "parameter_value": PlayerOrTeamAbbreviation.default,
        "parameter_error_value": 0,
    },
    "PlayerPosition": {
        "default_py_value": "PlayerPosition.default",
        "parameter_value": PlayerPosition.default,
        "parameter_error_value": 0,
    },
    "PlayerPositionNullable": {
        "default_py_value": "PlayerPositionNullable.default",
        "parameter_value": PlayerPositionNullable.default,
        "parameter_error_value": 0,
    },
    "PlayerPositionAbbreviation": {
        "default_py_value": "PlayerPositionAbbreviation.default",
        "parameter_value": PlayerPositionAbbreviation.default,
        "parameter_error_value": 0,
    },
    "PlayerPositionAbbreviationNullable": {
        "default_py_value": "PlayerPositionAbbreviationNullable.default",
        "parameter_value": PlayerPositionAbbreviationNullable.default,
        "parameter_error_value": 0,
    },
    "PlayerScope": {
        "default_py_value": "PlayerScope.default",
        "parameter_value": PlayerScope.default,
        "parameter_error_value": 0,
    },
    "PlayerTeamID": {
        "default_py_value": None,
        "parameter_value": "1610612739",  # Cleveland Cavaliers
        "parameter_error_value": "a",
    },
    "VsTeamID": {
        "default_py_value": None,
        "parameter_value": "1610612765",  # Detroit Pistons
        "parameter_error_value": "a",
    },
    "VsTeamIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "TeamID": {
        "default_py_value": None,
        "parameter_value": "1610612739",  # Cleveland Cavaliers
        "parameter_error_value": "a",
    },
    "TeamIDNullable": {
        "default_py_value": "''",
        "parameter_value": "0",  # Cleveland Cavaliers: 1610612739
        "parameter_error_value": "a",
    },
    "DLeagueTeamIDNullable": {
        "default_py_value": "0",
        "parameter_value": "0",  # Cleveland Cavaliers: 1610612739
        "parameter_error_value": "a",
    },
    "TodaysOpponent": {
        "default_py_value": 0,
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "OppTeamIDNullable": {
        "default_py_value": None,
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "OpponentTeamID": {
        "default_py_value": "0",
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "OpponentTeamIDNullable": {
        "default_py_value": "''",
        "parameter_value": "0",  # Dallas Mavericks: 1610612742
        "parameter_error_value": "a",
    },
    "DefTeamID": {
        "default_py_value": None,
        "parameter_value": "1610612742",  # Dallas Mavericks
        "parameter_error_value": "a",
    },
    "DefTeamIDNullable": {
        "default_py_value": None,
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "OffTeamID": {
        "default_py_value": None,
        "parameter_value": "1610612739",  # Cleveland Cavaliers
        "parameter_error_value": "a",
    },
    "OffTeamIDNullable": {
        "default_py_value": None,
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "PlayType": {
        "default_py_value": "PlayType.default",
        "parameter_value": PlayType.default,
        "parameter_error_value": 0,
    },
    "PlayTypeNullable": {
        "default_py_value": "PlayTypeNullable.default",
        "parameter_value": PlayTypeNullable.default,
        "parameter_error_value": 0,
    },
    "PointDf": {
        "default_py_value": "PointDf.default",
        "parameter_value": PointDf.default,
        "parameter_error_value": 0,
    },
    "PointDfNullable": {
        "default_py_value": "PointDfNullable.default",
        "parameter_value": PointDfNullable.default,
        "parameter_error_value": 0,
    },
    "PORoundNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "PositionNullable": {
        "default_py_value": "PositionNullable.default",
        "parameter_value": PositionNullable.default,
        "parameter_error_value": "a",
    },
    "PtMeasureType": {
        "default_py_value": "PtMeasureType.default",
        "parameter_value": PtMeasureType.default,
        "parameter_error_value": 0,
    },
    "RangeType": {
        "default_py_value": "RangeType.default",
        "parameter_value": RangeType.default,
        "parameter_error_value": "a",
    },
    "RangeTypeNullable": {
        "default_py_value": "RangeTypeNullable.default",
        "parameter_value": RangeTypeNullable.default,
        "parameter_error_value": "a",
    },
    "Sorter": {
        "default_py_value": "Sorter.default",
        "parameter_value": Sorter.default,
        "parameter_error_value": "a",
    },
    "StartRange": {
        "default_py_value": "StartRange.default",
        "parameter_value": StartRange.default,
        "parameter_error_value": "a",
    },
    "StartRangeNullable": {
        "default_py_value": "StartRangeNullable.default",
        "parameter_value": StartRangeNullable.default,
        "parameter_error_value": "a",
    },
    "EndRange": {
        "default_py_value": "EndRange.default",
        "parameter_value": EndRange.default,
        "parameter_error_value": "a",
    },
    "EndRangeNullable": {
        "default_py_value": "EndRangeNullable.default",
        "parameter_value": EndRangeNullable.default,
        "parameter_error_value": "a",
    },
    "Rank": {
        "default_py_value": "Rank.default",
        "parameter_value": Rank.default,
        "parameter_error_value": 0,
    },
    "RankNo": {
        "default_py_value": "RankNo.default",
        "parameter_value": RankNo.default,
        "parameter_error_value": 0,
    },
    "RoundNumNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "RoundPickNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "Scope": {
        "default_py_value": "Scope.default",
        "parameter_value": Scope.default,
        "parameter_error_value": "a",
    },
    "RunType": {
        "default_py_value": "RunType.default",
        "parameter_value": RunType.default,
        "parameter_error_value": "a",
    },
    "Person1SeasonYear": {
        "default_py_value": "SeasonYear.default",
        "parameter_value": SeasonYear.default,
        "parameter_error_value": "a",
    },
    "Person2SeasonYear": {
        "default_py_value": "SeasonYear.default",
        "parameter_value": SeasonYear.default,
        "parameter_error_value": "a",
    },
    "SeasonYear": {
        "default_py_value": "SeasonYear.default",
        "parameter_value": SeasonYear.default,
        "parameter_error_value": "a",
    },
    "SeasonYearNullable": {
        "default_py_value": "SeasonYearNullable.default",
        "parameter_value": SeasonYearNullable.default,
        "parameter_error_value": "a",
    },
    "Season": {
        "default_py_value": "Season.default",
        "parameter_value": Season.default,
        "parameter_error_value": "a",
    },
    "SeasonNullable": {
        "default_py_value": "SeasonNullable.default",
        "parameter_value": SeasonNullable.default,
        "parameter_error_value": "a",
    },
    "SeasonAll": {
        "default_py_value": "SeasonAll.default",
        "parameter_value": SeasonAll.default,
        "parameter_error_value": "a",
    },
    "SeasonAllNullable": {
        "default_py_value": "SeasonAllNullable.default",
        "parameter_value": SeasonAllNullable.default,
        "parameter_error_value": "a",
    },
    "SeasonAll_Time": {
        "default_py_value": "SeasonAll_Time.default",
        "parameter_value": SeasonAll_Time.default,
        "parameter_error_value": "a",
    },
    "SeasonAllTime": {
        "default_py_value": "SeasonAllTime.default",
        "parameter_value": SeasonAllTime.default,
        "parameter_error_value": "a",
    },
    "GraphStartSeason": {
        "default_py_value": "Season.default",
        "parameter_value": Season.default,
        "parameter_error_value": "a",
    },
    "GraphStartSeasonNullable": {
        "default_py_value": "SeasonNullable.default",
        "parameter_value": SeasonNullable.default,
        "parameter_error_value": "a",
    },
    "GraphEndSeason": {
        "default_py_value": "Season.default",
        "parameter_value": Season.default,
        "parameter_error_value": "a",
    },
    "GraphEndSeasonNullable": {
        "default_py_value": "SeasonNullable.default",
        "parameter_value": SeasonNullable.default,
        "parameter_error_value": "a",
    },
    "RookieYear": {
        "default_py_value": "Season.default",
        "parameter_value": Season.default,
        "parameter_error_value": "a",
    },
    "RookieYearNullable": {
        "default_py_value": "SeasonNullable.default",
        "parameter_value": SeasonNullable.default,
        "parameter_error_value": "a",
    },
    "SeasonID": {
        "default_py_value": "SeasonID.default",
        "parameter_value": SeasonID.default,
        "parameter_error_value": "a",
    },
    "SeasonIDNullable": {
        "default_py_value": "''",
        "parameter_value": SeasonID.default,
        "parameter_error_value": "a",
    },
    "Person1SeasonType": {
        "default_py_value": "SeasonType.default",
        "parameter_value": SeasonType.default,
        "parameter_error_value": "a",
    },
    "Person2SeasonType": {
        "default_py_value": "SeasonType.default",
        "parameter_value": SeasonType.default,
        "parameter_error_value": "a",
    },
    "SeasonType": {
        "default_py_value": "SeasonType.default",
        "parameter_value": SeasonType.default,
        "parameter_error_value": "a",
    },
    "SeasonTypePlayoffs": {
        "default_py_value": "SeasonType.default",
        "parameter_value": SeasonType.default,
        "parameter_error_value": "a",
    },
    "SeasonTypeNullable": {
        "default_py_value": "SeasonTypeNullable.default",
        "parameter_value": SeasonTypeNullable.default,
        "parameter_error_value": "a",
    },
    "SeasonTypeAllStar": {
        "default_py_value": "SeasonTypeAllStar.default",
        "parameter_value": SeasonTypeAllStar.default,
        "parameter_error_value": "a",
    },
    "SeasonTypeAllStarNullable": {
        "default_py_value": "SeasonTypeAllStarNullable.default",
        "parameter_value": SeasonTypeAllStarNullable.default,
        "parameter_error_value": "a",
    },
    "SeasonSegment": {
        "default_py_value": "SeasonSegment.default",
        "parameter_value": SeasonSegment.default,
        "parameter_error_value": "a",
    },
    "SeasonSegmentNullable": {
        "default_py_value": "SeasonSegmentNullable.default",
        "parameter_value": SeasonSegmentNullable.default,
        "parameter_error_value": "a",
    },
    "IsOnlyCurrentSeason": {
        "default_py_value": 0,
        "parameter_value": "0",
        "parameter_error_value": "a",
    },
    "SeriesIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "ShotClockRangeNullable": {
        "default_py_value": "ShotClockRangeNullable.default",
        "parameter_value": ShotClockRangeNullable.default,
        "parameter_error_value": "a",
    },
    "ShotDistRangeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "StarterBench": {
        "default_py_value": "StarterBench.default",
        "parameter_value": StarterBench.default,
        "parameter_error_value": 0,
    },
    "StarterBenchNullable": {
        "default_py_value": "StarterBenchNullable.default",
        "parameter_value": StarterBenchNullable.default,
        "parameter_error_value": 0,
    },
    "Stat": {
        "default_py_value": "Stat.default",
        "parameter_value": Stat.default,
        "parameter_error_value": 0,
    },
    "StatCategory": {
        "default_py_value": "StatCategory.default",
        "parameter_value": StatCategory.default,
        "parameter_error_value": 0,
    },
    "StatCategoryAbbreviation": {
        "default_py_value": "StatCategoryAbbreviation.default",
        "parameter_value": StatCategoryAbbreviation.default,
        "parameter_error_value": 0,
    },
    "StatType": {
        "default_py_value": "StatType.default",
        "parameter_value": StatType.default,
        "parameter_error_value": 0,
    },
    "TopX": {
        "default_py_value": "10",
        "parameter_value": 10,
        "parameter_error_value": "a",
    },
    "TopXNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "TouchTimeRangeNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "TypeGrouping": {
        "default_py_value": "TypeGrouping.default",
        "parameter_value": TypeGrouping.default,
        "parameter_error_value": 0,
    },
    "TypeGroupingNullable": {
        "default_py_value": "TypeGroupingNullable.default",
        "parameter_value": TypeGroupingNullable.default,
        "parameter_error_value": 0,
    },
    "WeightNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtDDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtTDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtMINUTESNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtFG3_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtDDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtTDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtMINUTESNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtFG3_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqDDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqTDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqMINUTESNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqFG3_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqOPPPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "ActiveStreaksOnlyNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFG3PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFG3PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPBLKNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "ActiveTeamsOnlyNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPDREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqOPPPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPASTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "MinGamesNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "MinutesMin": {
        "default_py_value": None,
        "parameter_value": "10",
        "parameter_error_value": "a",
    },
    "LtOPPFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPSTLNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqOPPPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFT_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPTSPAINTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPPFNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFTANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFG3PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WStreakNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFTMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPTS2NDCHANCENullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFG3ANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFGMNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPOREBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPPTSNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LtOPPTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "WrsOPPFGANullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPFG_PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqOPPPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFG3PCTNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "EqPTSFBNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "BtrOPPPTSOFFTOVNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "LStreakNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "GtOPPFG3MNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DraftNumberNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "YearsExperienceNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DraftTeamIDNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "DraftRoundNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
    "TwoWayNullable": {
        "default_py_value": "''",
        "parameter_value": "",
        "parameter_error_value": "a",
    },
}

parameter_map  {
    "ActiveFlag": {"nullable": {None: "ActiveFlagNullable"}, "non-nullable": {}},
    "AheadBehind": {
        "nullable": {
            "^((Ahead or Behind)|(Ahead or Tied)|(Behind or Tied))?$": "AheadBehindNullable",
            None: "AheadBehindNullable",
        },
        "non-nullable": {
            "^((Ahead or Behind)|(Behind or Tied)|(Ahead or Tied))?$": "AheadBehind"
        },
    },
    "CloseDefDistRange": {
        "nullable": {None: "CloseDefDistRangeNullable"},
        "non-nullable": {},
    },
    "ClutchTime": {
        "nullable": {
            "^((Last 5 Minutes)|(Last 4 Minutes)|(Last 3 Minutes)|(Last 2 Minutes)|(Last 1 Minute)|(Last 30 Seconds)|(Last 10 Seconds))?$": "ClutchTimeNullable",
            None: "ClutchTimeNullable",
        },
        "non-nullable": {
            "^((Last 5 Minutes)|(Last 4 Minutes)|(Last 3 Minutes)|(Last 2 Minutes)|(Last 1 Minute)|(Last 30 Seconds)|(Last 10 Seconds))?$": "ClutchTime"
        },
    },
    "College": {
        "nullable": {None: "CollegeNullable"},
        "non-nullable": {None: "College"},
    },
    "School": {"nullable": {}, "non-nullable": {None: "College"}},
    "Conference": {
        "nullable": {
            "((East)|(West))?": "ConferenceNullable",
            "^((East)|(West))?$": "ConferenceNullable",
            None: "ConferenceNullable",
        },
        "non-nullable": {},
    },
    "ContextFilter": {"nullable": {None: "ContextFilterNullable"}, "non-nullable": {}},
    "ContextMeasure": {
        "nullable": {
            "^((PTS)|(FGM)|(FGA)|(FG_PCT)|(FG3M)|(FG3A)|(FG3_PCT)|(PF)|(EFG_PCT)|(TS_PCT)|(PTS_FB)|(PTS_OFF_TOV)|(PTS_2ND_CHANCE)|(PF))?$": "ContextMeasureSimpleNullable"
        },
        "non-nullable": {
            "^((PTS)|(FGM)|(FGA)|(FG_PCT)|(FG3M)|(FG3A)|(FG3_PCT)|(PF)|(EFG_PCT)|(TS_PCT)|(PTS_FB)|(PTS_OFF_TOV)|(PTS_2ND_CHANCE)|(PF))?$": "ContextMeasureSimple",
            "^((PTS)|(FGM)|(FGA)|(FG_PCT)|(FG3M)|(FG3A)|(FG3_PCT)|(FTM)|(FTA)|(OREB)|(DREB)|(AST)|(FGM_AST)|(FG3_AST)|(STL)|(BLK)|(BLKA)|(TOV)|(POSS_END_FT)|(PTS_PAINT)|(PTS_FB)|(PTS_OFF_TOV)|(PTS_2ND_CHANCE)|(REB)|(TM_FGM)|(TM_FGA)|(TM_FG3M)|(TM_FG3A)|(TM_FTM)|(TM_FTA)|(TM_OREB)|(TM_DREB)|(TM_REB)|(TM_TEAM_REB)|(TM_AST)|(TM_STL)|(TM_BLK)|(TM_BLKA)|(TM_TOV)|(TM_TEAM_TOV)|(TM_PF)|(TM_PFD)|(TM_PTS)|(TM_PTS_PAINT)|(TM_PTS_FB)|(TM_PTS_OFF_TOV)|(TM_PTS_2ND_CHANCE)|(TM_FGM_AST)|(TM_FG3_AST)|(TM_POSS_END_FT)|(OPP_FTM)|(OPP_FTA)|(OPP_OREB)|(OPP_DREB)|(OPP_REB)|(OPP_TEAM_REB)|(OPP_AST)|(OPP_STL)|(OPP_BLK)|(OPP_BLKA)|(OPP_TOV)|(OPP_TEAM_TOV)|(OPP_PF)|(OPP_PFD)|(OPP_PTS)|(OPP_PTS_PAINT)|(OPP_PTS_FB)|(OPP_PTS_OFF_TOV)|(OPP_PTS_2ND_CHANCE)|(OPP_FGM_AST)|(OPP_FG3_AST)|(OPP_POSS_END_FT)|(PTS))$": "ContextMeasureDetailed",
            "^((FGM)|(FGA)|(FG_PCT)|(FG3M)|(FG3A)|(FG3_PCT)|(FTM)|(FTA)|(OREB)|(DREB)|(AST)|(FGM_AST)|(FG3_AST)|(STL)|(BLK)|(BLKA)|(TOV)|(PF)|(PFD)|(POSS_END_FT)|(PTS_PAINT)|(PTS_FB)|(PTS_OFF_TOV)|(PTS_2ND_CHANCE)|(REB)|(TM_FGM)|(TM_FGA)|(TM_FG3M)|(TM_FG3A)|(TM_FTM)|(TM_FTA)|(TM_OREB)|(TM_DREB)|(TM_REB)|(TM_TEAM_REB)|(TM_AST)|(TM_STL)|(TM_BLK)|(TM_BLKA)|(TM_TOV)|(TM_TEAM_TOV)|(TM_PF)|(TM_PFD)|(TM_PTS)|(TM_PTS_PAINT)|(TM_PTS_FB)|(TM_PTS_OFF_TOV)|(TM_PTS_2ND_CHANCE)|(TM_FGM_AST)|(TM_FG3_AST)|(TM_POSS_END_FT)|(OPP_FGM)|(OPP_FGA)|(OPP_FG3M)|(OPP_FG3A)|(OPP_FTM)|(OPP_FTA)|(OPP_OREB)|(OPP_DREB)|(OPP_REB)|(OPP_TEAM_REB)|(OPP_AST)|(OPP_STL)|(OPP_BLK)|(OPP_BLKA)|(OPP_TOV)|(OPP_TEAM_TOV)|(OPP_PF)|(OPP_PFD)|(OPP_PTS)|(OPP_PTS_PAINT)|(OPP_PTS_FB)|(OPP_PTS_OFF_TOV)|(OPP_PTS_2ND_CHANCE)|(OPP_FGM_AST)|(OPP_FG3_AST)|(OPP_POSS_END_FT)|(PTS))$": "ContextMeasureDetailed",
        },
    },
    "Counter": {
        "nullable": {
            None: "CounterNullable",
        },
        "non-nullable": {None: "Counter"},
    },
    "Country": {"nullable": {None: "CountryNullable"}, "non-nullable": {}},
    "DateFrom": {"nullable": {None: "DateFromNullable"}, "non-nullable": {}},
    "DateTo": {"nullable": {None: "DateToNullable"}, "non-nullable": {}},
    "DayOffset": {"nullable": {}, "non-nullable": {"^-{0,1}\\d+$": "DayOffset"}},
    "DefenseCategory": {
        "nullable": {
            "^((Overall)|(3 Pointers)|(2 Pointers)|(Less Than 6Ft)|(Less Than 10Ft)|(Greater Than 15Ft))?$": "DefenseCategoryNullable"
        },
        "non-nullable": {
            "^((Overall)|(3 Pointers)|(2 Pointers)|(Less Than 6Ft)|(Less Than 10Ft)|(Greater Than 15Ft))?$": "DefenseCategory"
        },
    },
    "Direction": {"nullable": {}, "non-nullable": {"^(ASC)|(DESC)$": "Direction"}},
    "DistanceRange": {
        "nullable": {},
        "non-nullable": {"^(5ft Range)|(8ft Range)|(By Zone)$": "DistanceRange"},
    },
    "Division": {
        "nullable": {
            None: "DivisionSimpleNullable",
            "((Atlantic)|(Central)|(Northwest)|(Pacic)|(Southeast)|(Southwest))?": "DivisionSimpleNullable",
            "^((Atlantic)|(Central)|(Northwest)|(Pacic)|(Southeast)|(Southwest)|(East)|(West))?$": "DivisionNullable",
        },
        "non-nullable": {},
    },
    "DraftPick": {"nullable": {None: "DraftPickNullable"}, "non-nullable": {}},
    "DraftYear": {"nullable": {None: "DraftYearNullable"}, "non-nullable": {}},
    "DribbleRange": {"nullable": {None: "DribbleRangeNullable"}, "non-nullable": {}},
    "EastPlayer1": {"nullable": {}, "non-nullable": {None: "EastPlayer1"}},
    "EastPlayer2": {"nullable": {}, "non-nullable": {None: "EastPlayer2"}},
    "EastPlayer3": {"nullable": {}, "non-nullable": {None: "EastPlayer3"}},
    "EastPlayer4": {"nullable": {}, "non-nullable": {None: "EastPlayer4"}},
    "EastPlayer5": {"nullable": {}, "non-nullable": {None: "EastPlayer5"}},
    "EndPeriod": {
        "nullable": {None: "EndPeriodNullable"},
        "non-nullable": {None: "EndPeriod"},
    },
    "EndRange": {
        "nullable": {None: "EndRangeNullable"},
        "non-nullable": {None: "EndRange"},
    },
    "GROUP_ID": {
        "nullable": {},
        "non-nullable": {"^\\d+(( - \\d+){2,4})?$": "GroupID"},
    },
    "GameDate": {"nullable": {}, "non-nullable": {None: "GameDate"}},
    "GameEventID": {"nullable": {}, "non-nullable": {None: "GameEventID"}},
    "GameID": {
        "nullable": {"^(\\d{10})?$": "GameIDNullable", None: "GameIDNullable"},
        "non-nullable": {
            "^(\\d{10})?$": "GameID",
            "^\\d{10}$": "GameID",
            None: "GameID",
        },
    },
    "GameIDs": {"nullable": {}, "non-nullable": {None: "GameIDs"}},
    "GameScope": {
        "nullable": {"((Yesterday)|(Last 10))?": "GameScopeSimpleNullable"},
        "non-nullable": {
            "^(Season)|(Last 10)|(Yesterday)|(Finals)$": "GameScopeDetailed"
        },
    },
    "GameSegment": {
        "nullable": {
            "^((First Half)|(Overtime)|(Second Half))?$": "GameSegmentNullable",
            None: "GameSegmentNullable",
        },
        "non-nullable": {},
    },
    "GeneralRange": {"nullable": {None: "GeneralRangeNullable"}, "non-nullable": {}},
    "GraphEndSeason": {
        "nullable": {"^(\\d{4}-\\d{2})?$": "GraphEndSeasonNullable"},
        "non-nullable": {},
    },
    "GraphStartSeason": {
        "nullable": {"^(\\d{4}-\\d{2})?$": "GraphStartSeasonNullable"},
        "non-nullable": {},
    },
    "GraphStat": {"nullable": {None: "GraphStatNullable"}, "non-nullable": {}},
    "GroupQuantity": {"nullable": {}, "non-nullable": {None: "GroupQuantity"}},
    "Height": {"nullable": {None: "HeightNullable"}, "non-nullable": {}},
    "IsOnlyCurrentSeason": {
        "nullable": {None: "IsOnlyCurrentSeason"},
        "non-nullable": {None: "IsOnlyCurrentSeason"},
    },
    "LastNGames": {
        "nullable": {None: "LastNGamesNullable"},
        "non-nullable": {None: "LastNGames"},
    },
    "Person1LeagueId": {"nullable": {}, "non-nullable": {None: "Person1LeagueID"}},
    "Person2LeagueId": {"nullable": {}, "non-nullable": {None: "Person2LeagueID"}},
    "LeagueID": {
        "nullable": {
            "(00)|(20)|(10)": "LeagueIDNullable",
            "^((00)|(20))?$": "LeagueIDNullable",
            "^\\d{2}$": "LeagueIDNullable",
            None: "LeagueIDNullable",
        },
        "non-nullable": {
            "^\\d{2}$": "LeagueID",
            "^(00)|(10)|(20)$": "LeagueID",
            "(00)|(20)|(10)": "LeagueID",
            "^(00)|(20)$": "LeagueID",
            "^((00)|(20))?$": "LeagueID",
            "^(00)|(20)|(10)$": "LeagueID",
            None: "LeagueID",
        },
    },
    "Location": {
        "nullable": {
            "^((Home)|(Road))?$": "LocationNullable",
            None: "LocationNullable",
        },
        "non-nullable": {},
    },
    "MeasureType": {
        "nullable": {
            None: "MeasureTypePlayerGameLogsNullable",
        },
        "non-nullable": {
            "^(Base)$": "MeasureTypeBase",
            "^(Base)|(Opponent)$": "MeasureTypeSimple",
            "^(Base)|(Advanced)|(Misc)|(Four Factors)|(Scoring)|(Opponent)|(Usage)$": "MeasureTypeDetailed",
            "^(Base)|(Advanced)|(Misc)|(Four Factors)|(Scoring)|(Opponent)|(Usage)|(Defense)$": "MeasureTypeDetailedDefense",
        },
    },
    "Month": {"nullable": {None: "MonthNullable"}, "non-nullable": {None: "Month"}},
    "NumberOfGames": {"nullable": {}, "non-nullable": {None: "NumberOfGames"}},
    "OppTeamID": {"nullable": {None: "OppTeamIDNullable"}, "non-nullable": {}},
    "OpponentTeamID": {
        "nullable": {None: "OpponentTeamIDNullable"},
        "non-nullable": {None: "OpponentTeamID"},
    },
    "Outcome": {
        "nullable": {"^((W)|(L))?$": "OutcomeNullable", None: "OutcomeNullable"},
        "non-nullable": {},
    },
    "OverallPick": {"nullable": {None: "OverallPickNullable"}, "non-nullable": {}},
    "PORound": {"nullable": {None: "PORoundNullable"}, "non-nullable": {}},
    "PaceAdjust": {
        "nullable": {},
        "non-nullable": {"^(N)$": "PaceAdjustNo", "^(Y)|(N)$": "PaceAdjust"},
    },
    "PerMode": {
        "nullable": {
            "^(Totals)|(PerGame)$": "PerModeSimpleNullable",
            None: "PerModeSimpleNullable",
        },
        "non-nullable": {
            None: "PerModeSimple",
            "^(Totals)|(PerGame)$": "PerModeSimple",
            "^(Totals)|(PerGame)|(Per36)$": "PerMode36",
            "^(Totals)|(PerGame)|(Per48)$": "PerMode48",
            "^(Totals)|(PerGame)|(Per48)|(Per40)|(Per36)|(PerMinute)$": "PerModeTime",
            "^(Totals)|(PerGame)|(MinutesPer)|(Per48)|(Per40)|(Per36)|(PerMinute)|(PerPossession)|(PerPlay)|(Per100Possessions)|(Per100Plays)$": "PerModeDetailed",
        },
    },
    "Period": {"nullable": {None: "PeriodNullable"}, "non-nullable": {None: "Period"}},
    "PlayerExperience": {
        "nullable": {
            "((Rookie)|(Sophomore)|(Veteran))?": "PlayerExperienceNullable",
            None: "PlayerExperienceNullable",
        },
        "non-nullable": {},
    },
    "ActivePlayers": {"nullable": {}, "non-nullable": {"^(Y)|(N)$": "ActivePlayers"}},
    "TodaysPlayers": {"nullable": {}, "non-nullable": {"^(Y)|(N)$": "TodaysPlayers"}},
    "PlayerID": {
        "nullable": {None: "PlayerIDNullable"},
        "non-nullable": {None: "PlayerID"},
    },
    "Person1Id": {"nullable": {}, "non-nullable": {None: "Person1ID"}},
    "Person2Id": {"nullable": {}, "non-nullable": {None: "Person2ID"}},
    "PlayerID1": {"nullable": {}, "non-nullable": {None: "PlayerID1"}},
    "PlayerID2": {"nullable": {}, "non-nullable": {None: "PlayerID2"}},
    "PlayerID3": {"nullable": {}, "non-nullable": {None: "PlayerID3"}},
    "PlayerID4": {"nullable": {}, "non-nullable": {None: "PlayerID4"}},
    "PlayerID5": {"nullable": {}, "non-nullable": {None: "PlayerID5"}},
    "DefPlayerID": {"nullable": {None: "DefPlayerIDNullable"}, "non-nullable": {}},
    "OffPlayerID": {"nullable": {None: "OffPlayerIDNullable"}, "non-nullable": {}},
    "PlayerIDList": {"nullable": {}, "non-nullable": {None: "PlayerIDList"}},
    "PlayerOrTeam": {
        "nullable": {},
        "non-nullable": {
            "^(Player)|(Team)$": "PlayerOrTeam",
            "^(P)|(T)$": "PlayerOrTeamAbbreviation",
        },
    },
    "PlayerPosition": {
        "nullable": {
            "((F)|(C)|(G)|(C-F)|(F-C)|(F-G)|(G-F))?": "PlayerPositionAbbreviationNullable",
            "^((Guard)|(Center)|(Forward))?$": "PlayerPositionNullable",
            None: "PlayerPositionNullable",
        },
        "non-nullable": {},
    },
    "PlayerScope": {
        "nullable": {},
        "non-nullable": {"^(All Players)|(Rookies)$": "PlayerScope"},
    },
    "PlayerTeamID": {"nullable": {}, "non-nullable": {None: "PlayerTeamID"}},
    "PlayType": {
        "nullable": {
            None: "PlayTypeNullable",
        },
        "non-nullable": {},
    },
    "PlusMinus": {
        "nullable": {},
        "non-nullable": {"^(N)$": "PlusMinusNo", "^(Y)|(N)$": "PlusMinus"},
    },
    "PointDf": {
        "nullable": {None: "PointDfNullable"},
        "non-nullable": {None: "PointDf"},
    },
    "Position": {
        "nullable": {
            None: "PositionNullable",
            "^(Guard|Forward|Center)?$": "PositionNullable",
        },
        "non-nullable": {},
    },
    "PtMeasureType": {
        "nullable": {},
        "non-nullable": {
            "^(SpeedDistance)|(Rebounding)|(Possessions)|(CatchShoot)|(PullUpShot)|(Defense)|(Drives)|(Passing)|(ElbowTouch)|(PostTouch)|(PaintTouch)|(Efficiency)$": "PtMeasureType"
        },
    },
    "RangeType": {
        "nullable": {None: "RangeTypeNullable"},
        "non-nullable": {None: "RangeType"},
    },
    "Rank": {"nullable": {}, "non-nullable": {"^(N)$": "RankNo", "^(Y)|(N)$": "Rank"}},
    "RookieYear": {
        "nullable": {
            "^(\\d{4}-\\d{2})?$": "RookieYearNullable",
            None: "RookieYearNullable",
        },
        "non-nullable": {},
    },
    "RoundNum": {"nullable": {None: "RoundNumNullable"}, "non-nullable": {}},
    "RoundPick": {"nullable": {None: "RoundPickNullable"}, "non-nullable": {}},
    "RunType": {"nullable": {}, "non-nullable": {None: "RunType"}},
    "Runtype": {"nullable": {}, "non-nullable": {None: "RunType"}},
    "Scope": {"nullable": {}, "non-nullable": {"^(RS)|(S)|(Rookies)$": "Scope"}},
    "Person1Season": {
        "nullable": {},
        "non-nullable": {
            None: "Person1SeasonYear",
        },
    },
    "Person2Season": {
        "nullable": {},
        "non-nullable": {
            None: "Person2SeasonYear",
        },
    },
    "Season": {
        "nullable": {
            "^\\d{4}$": "SeasonYearNullable",
            "^(\\d{4}-\\d{2})?$": "SeasonNullable",
            "^(\\d{4}-\\d{2})|(ALL)$": "SeasonAllNullable",
            None: "SeasonNullable",
        },
        "non-nullable": {
            None: "Season",
            "^\\d{4}$": "SeasonYear",
            "^(\\d{4}-\\d{2})$": "Season",
            "^\\d{4}-\\d{2}$": "Season",
            "^(\\d{4}-\\d{2})?$": "Season",
            "^(\\d{4}-\\d{2})|(All Time)$": "SeasonAll_Time",
            "^(\\d{4}-\\d{2})|(ALLTIME)$": "SeasonAllTime",
            "^(\\d{4}-\\d{2})|(ALL)$": "SeasonAll",
        },
    },
    "SeasonID": {
        "nullable": {
            None: "SeasonIDNullable",
        },
        "non-nullable": {None: "SeasonID", "^\\d{5}$": "SeasonID"},
    },
    "SeasonSegment": {
        "nullable": {
            "^((Post All-Star)|(Pre All-Star))?$": "SeasonSegmentNullable",
            None: "SeasonSegmentNullable",
        },
        "non-nullable": {},
    },
    "Person1SeasonType": {
        "nullable": {},
        "non-nullable": {
            None: "Person1SeasonType",
        },
    },
    "Person2SeasonType": {
        "nullable": {},
        "non-nullable": {
            None: "Person2SeasonType",
        },
    },
    "SeasonType": {
        "nullable": {
            None: "SeasonTypeNullable",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All-Star)|(All Star)|(Preseason)$": "SeasonTypeAllStarNullable",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All Star)$": "SeasonTypeAllStarNullable",
        },
        "non-nullable": {
            None: "SeasonType",
            "^(Regular Season)|(Pre Season)$": "SeasonType",
            "^(Regular Season)|(Pre Season)|(Playoffs)$": "SeasonTypePlayoffs",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(Pre-Season)$": "SeasonTypePlayoffs",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All Star)$": "SeasonTypeAllStar",
            "^((Regular Season)|(Pre Season)|(Playoffs)|(All Star))?$": "SeasonTypeAllStar",
            "^(Regular Season)|(Playoffs)|(All Star)|(Pre Season)$": "SeasonTypeAllStar",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All-Star)|(All Star)|(Preseason)$": "SeasonTypeAllStar",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All-Star)|(All Star)$": "SeasonTypeAllStar",
            "^(Regular Season)|(Pre Season)|(Playoffs)|(All Star)|(All-Star)$": "SeasonTypeAllStar",
        },
    },
    "SeasonYear": {
        "nullable": {
            None: "SeasonNullable",
        },
        "non-nullable": {
            "^\\d{4}-\\d{2}$": "Season",
            None: "SeasonYear",
            "^(\\d{4}-\\d{2})|(All Time)$": "SeasonAll_Time",
            "^(\\d{4}-\\d{2})|(\\d{4})$": "Season",
        },
    },
    "Section": {"non-nullable": {"^(group)|(wildcard)$": "Section"}},
    "SeriesID": {"nullable": {None: "SeriesIDNullable"}, "non-nullable": {}},
    "ShotClockRange": {
        "nullable": {
            "((24-22)|(22-18 Very Early)|(18-15 Early)|(15-7 Average)|(7-4 Late)|(4-0 Very Late)|(ShotClock Off))?": "ShotClockRangeNullable",
            None: "ShotClockRangeNullable",
        },
        "non-nullable": {},
    },
    "ShotDistRange": {"nullable": {None: "ShotDistRangeNullable"}, "non-nullable": {}},
    "Sorter": {
        "nullable": {},
        "non-nullable": {
            "^((FGM)|(FGA)|(FG_PCT)|(FG3M)|(FG3A)|(FG3_PCT)|(FTM)|(FTA)|(FT_PCT)|(OREB)|(DREB)|(AST)|(STL)|(BLK)|(TOV)|(REB)|(PTS)|(DATE))$": "Sorter"
        },
    },
    "StartPeriod": {
        "nullable": {None: "StartPeriodNullable"},
        "non-nullable": {None: "StartPeriod"},
    },
    "StartRange": {
        "nullable": {None: "StartRangeNullable"},
        "non-nullable": {None: "StartRange"},
    },
    "StarterBench": {
        "nullable": {
            "((Starters)|(Bench))?": "StarterBenchNullable",
            None: "StarterBenchNullable",
        },
        "non-nullable": {},
    },
    "Stat": {
        "nullable": {},
        "non-nullable": {
            "^(PTS)|(REB)|(AST)|(FG_PCT)|(FT_PCT)|(FG3_PCT)|(STL)|(BLK)$": "Stat"
        },
    },
    "StatCategory": {
        "nullable": {},
        "non-nullable": {
            None: "StatCategoryAbbreviation",
            "^(Points)|(Rebounds)|(Assists)|(Defense)|(Clutch)|(Playmaking)|(Efficiency)|(Fast Break)|(Scoring Breakdown)$": "StatCategory",
        },
    },
    "StatType": {
        "nullable": {},
        "non-nullable": {"^(Traditional)|(Advanced)|(Tracking)$": "StatType"},
    },
    "DLeagueTeamID": {"nullable": {None: "DLeagueTeamIDNullable"}, "non-nullable": {}},
    "NBATeamID": {"nullable": {}, "non-nullable": {None: "TeamID"}},
    "TeamID": {"nullable": {None: "TeamIDNullable"}, "non-nullable": {None: "TeamID"}},
    "TodaysOpponent": {"nullable": {}, "non-nullable": {None: "TodaysOpponent"}},
    "DefTeamID": {
        "nullable": {None: "DefTeamIDNullable"},
        "non-nullable": {None: "DefTeamID"},
    },
    "OffTeamID": {
        "nullable": {None: "OffTeamIDNullable"},
        "non-nullable": {None: "OffTeamID"},
    },
    "TopX": {"nullable": {None: "TopXNullable"}, "non-nullable": {None: "TopX"}},
    "TouchTimeRange": {
        "nullable": {None: "TouchTimeRangeNullable"},
        "non-nullable": {},
    },
    "TypeGrouping": {
        "nullable": {
            None: "TypeGroupingNullable",
        },
        "non-nullable": {},
    },
    "VsConference": {
        "nullable": {
            "^((East)|(West))?$": "VsConferenceNullable",
            None: "VsConferenceNullable",
        },
        "non-nullable": {},
    },
    "VsDivision": {
        "nullable": {
            "^((Atlantic)|(Central)|(Northwest)|(Pacic)|(Southeast)|(Southwest)|(East)|(West))?$": "VsDivisionNullable",
            None: "VsDivisionNullable",
        },
        "non-nullable": {},
    },
    "VsPlayerID": {"nullable": {}, "non-nullable": {None: "VsPlayerID"}},
    "VsPlayerID1": {"nullable": {}, "non-nullable": {None: "VsPlayerID1"}},
    "VsPlayerID2": {"nullable": {}, "non-nullable": {None: "VsPlayerID2"}},
    "VsPlayerID3": {"nullable": {}, "non-nullable": {None: "VsPlayerID3"}},
    "VsPlayerID4": {"nullable": {}, "non-nullable": {None: "VsPlayerID4"}},
    "VsPlayerID5": {"nullable": {}, "non-nullable": {None: "VsPlayerID5"}},
    "VsPlayerIDList": {"nullable": {}, "non-nullable": {None: "VsPlayerIDList"}},
    "VsTeamID": {
        "nullable": {None: "VsTeamIDNullable"},
        "non-nullable": {None: "VsTeamID"},
    },
    "Weight": {"nullable": {None: "WeightNullable"}, "non-nullable": {}},
    "WestPlayer1": {"nullable": {}, "non-nullable": {None: "WestPlayer1"}},
    "WestPlayer2": {"nullable": {}, "non-nullable": {None: "WestPlayer2"}},
    "WestPlayer3": {"nullable": {}, "non-nullable": {None: "WestPlayer3"}},
    "WestPlayer4": {"nullable": {}, "non-nullable": {None: "WestPlayer4"}},
    "WestPlayer5": {"nullable": {}, "non-nullable": {None: "WestPlayer5"}},
    "GtPTS": {"nullable": {None: "GtPTSNullable"}, "non-nullable": {}},
    "GtREB": {"nullable": {None: "GtREBNullable"}, "non-nullable": {}},
    "GtAST": {"nullable": {None: "GtASTNullable"}, "non-nullable": {}},
    "GtSTL": {"nullable": {None: "GtSTLNullable"}, "non-nullable": {}},
    "GtBLK": {"nullable": {None: "GtBLKNullable"}, "non-nullable": {}},
    "GtOREB": {"nullable": {None: "GtOREBNullable"}, "non-nullable": {}},
    "GtDREB": {"nullable": {None: "GtDREBNullable"}, "non-nullable": {}},
    "GtDD": {"nullable": {None: "GtDDNullable"}, "non-nullable": {}},
    "GtTD": {"nullable": {None: "GtTDNullable"}, "non-nullable": {}},
    "GtMINUTES": {"nullable": {None: "GtMINUTESNullable"}, "non-nullable": {}},
    "GtTOV": {"nullable": {None: "GtTOVNullable"}, "non-nullable": {}},
    "GtPF": {"nullable": {None: "GtPFNullable"}, "non-nullable": {}},
    "GtFGM": {"nullable": {None: "GtFGMNullable"}, "non-nullable": {}},
    "GtFGA": {"nullable": {None: "GtFGANullable"}, "non-nullable": {}},
    "GtFG_PCT": {"nullable": {None: "GtFG_PCTNullable"}, "non-nullable": {}},
    "GtFTM": {"nullable": {None: "GtFTMNullable"}, "non-nullable": {}},
    "GtFTA": {"nullable": {None: "GtFTANullable"}, "non-nullable": {}},
    "GtFT_PCT": {"nullable": {None: "GtFT_PCTNullable"}, "non-nullable": {}},
    "GtFG3M": {"nullable": {None: "GtFG3MNullable"}, "non-nullable": {}},
    "GtFG3A": {"nullable": {None: "GtFG3ANullable"}, "non-nullable": {}},
    "GtFG3_PCT": {"nullable": {None: "GtFG3_PCTNullable"}, "non-nullable": {}},
    "LtPTS": {"nullable": {None: "LtPTSNullable"}, "non-nullable": {}},
    "LtREB": {"nullable": {None: "LtREBNullable"}, "non-nullable": {}},
    "LtAST": {"nullable": {None: "LtASTNullable"}, "non-nullable": {}},
    "LtSTL": {"nullable": {None: "LtSTLNullable"}, "non-nullable": {}},
    "LtBLK": {"nullable": {None: "LtBLKNullable"}, "non-nullable": {}},
    "LtOREB": {"nullable": {None: "LtOREBNullable"}, "non-nullable": {}},
    "LtDREB": {"nullable": {None: "LtDREBNullable"}, "non-nullable": {}},
    "LtDD": {"nullable": {None: "LtDDNullable"}, "non-nullable": {}},
    "LtTD": {"nullable": {None: "LtTDNullable"}, "non-nullable": {}},
    "LtMINUTES": {"nullable": {None: "LtMINUTESNullable"}, "non-nullable": {}},
    "LtTOV": {"nullable": {None: "LtTOVNullable"}, "non-nullable": {}},
    "LtPF": {"nullable": {None: "LtPFNullable"}, "non-nullable": {}},
    "LtFGM": {"nullable": {None: "LtFGMNullable"}, "non-nullable": {}},
    "LtFGA": {"nullable": {None: "LtFGANullable"}, "non-nullable": {}},
    "LtFG_PCT": {"nullable": {None: "LtFG_PCTNullable"}, "non-nullable": {}},
    "LtFTM": {"nullable": {None: "LtFTMNullable"}, "non-nullable": {}},
    "LtFTA": {"nullable": {None: "LtFTANullable"}, "non-nullable": {}},
    "LtFT_PCT": {"nullable": {None: "LtFT_PCTNullable"}, "non-nullable": {}},
    "LtFG3M": {"nullable": {None: "LtFG3MNullable"}, "non-nullable": {}},
    "LtFG3A": {"nullable": {None: "LtFG3ANullable"}, "non-nullable": {}},
    "LtFG3_PCT": {"nullable": {None: "LtFG3_PCTNullable"}, "non-nullable": {}},
    "EqPTS": {"nullable": {None: "EqPTSNullable"}, "non-nullable": {}},
    "EqREB": {"nullable": {None: "EqREBNullable"}, "non-nullable": {}},
    "EqAST": {"nullable": {None: "EqASTNullable"}, "non-nullable": {}},
    "EqSTL": {"nullable": {None: "EqSTLNullable"}, "non-nullable": {}},
    "EqBLK": {"nullable": {None: "EqBLKNullable"}, "non-nullable": {}},
    "EqOREB": {"nullable": {None: "EqOREBNullable"}, "non-nullable": {}},
    "EqDREB": {"nullable": {None: "EqDREBNullable"}, "non-nullable": {}},
    "EqDD": {"nullable": {None: "EqDDNullable"}, "non-nullable": {}},
    "EqTD": {"nullable": {None: "EqTDNullable"}, "non-nullable": {}},
    "EqMINUTES": {"nullable": {None: "EqMINUTESNullable"}, "non-nullable": {}},
    "EqTOV": {"nullable": {None: "EqTOVNullable"}, "non-nullable": {}},
    "EqPF": {"nullable": {None: "EqPFNullable"}, "non-nullable": {}},
    "EqFGM": {"nullable": {None: "EqFGMNullable"}, "non-nullable": {}},
    "EqFGA": {"nullable": {None: "EqFGANullable"}, "non-nullable": {}},
    "EqFG_PCT": {"nullable": {None: "EqFG_PCTNullable"}, "non-nullable": {}},
    "EqFTM": {"nullable": {None: "EqFTMNullable"}, "non-nullable": {}},
    "EqFTA": {"nullable": {None: "EqFTANullable"}, "non-nullable": {}},
    "EqFT_PCT": {"nullable": {None: "EqFT_PCTNullable"}, "non-nullable": {}},
    "EqFG3M": {"nullable": {None: "EqFG3MNullable"}, "non-nullable": {}},
    "EqFG3A": {"nullable": {None: "EqFG3ANullable"}, "non-nullable": {}},
    "EqFG3_PCT": {"nullable": {None: "EqFG3_PCTNullable"}, "non-nullable": {}},
    "GtOPPPTSOFFTOV": {
        "nullable": {None: "GtOPPPTSOFFTOVNullable"},
        "non-nullable": {},
    },
    "GtOPPTOV": {"nullable": {None: "GtOPPTOVNullable"}, "non-nullable": {}},
    "EqOPPPTS2NDCHANCE": {
        "nullable": {None: "EqOPPPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "GtOPPPTSPAINT": {"nullable": {None: "GtOPPPTSPAINTNullable"}, "non-nullable": {}},
    "ActiveStreaksOnly": {
        "nullable": {None: "ActiveStreaksOnlyNullable"},
        "non-nullable": {},
    },
    "GtOPPFG3A": {"nullable": {None: "GtOPPFG3ANullable"}, "non-nullable": {}},
    "WrsOPPBLK": {"nullable": {None: "WrsOPPBLKNullable"}, "non-nullable": {}},
    "LtPTS2NDCHANCE": {
        "nullable": {None: "LtPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "LtOPPSTL": {"nullable": {None: "LtOPPSTLNullable"}, "non-nullable": {}},
    "GtOPPFTA": {"nullable": {None: "GtOPPFTANullable"}, "non-nullable": {}},
    "GtOPPFG_PCT": {"nullable": {None: "GtOPPFG_PCTNullable"}, "non-nullable": {}},
    "GtPTS2NDCHANCE": {
        "nullable": {None: "GtPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "BtrOPPDREB": {"nullable": {None: "BtrOPPDREBNullable"}, "non-nullable": {}},
    "BtrOPPPTSPAINT": {
        "nullable": {None: "BtrOPPPTSPAINTNullable"},
        "non-nullable": {},
    },
    "LtOPPPTS2NDCHANCE": {
        "nullable": {None: "LtOPPPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "GtOPPAST": {"nullable": {None: "GtOPPASTNullable"}, "non-nullable": {}},
    "GtOPPOREB": {"nullable": {None: "GtOPPOREBNullable"}, "non-nullable": {}},
    "BtrOPPBLK": {"nullable": {None: "BtrOPPBLKNullable"}, "non-nullable": {}},
    "LtPTSOFFTOV": {"nullable": {None: "LtPTSOFFTOVNullable"}, "non-nullable": {}},
    "LtOPPFGM": {"nullable": {None: "LtOPPFGMNullable"}, "non-nullable": {}},
    "WrsOPPPTS2NDCHANCE": {
        "nullable": {None: "WrsOPPPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "BtrOPPFG3M": {"nullable": {None: "BtrOPPFG3MNullable"}, "non-nullable": {}},
    "WrsOPPPTSOFFTOV": {
        "nullable": {None: "WrsOPPPTSOFFTOVNullable"},
        "non-nullable": {},
    },
    "BtrOPPOREB": {"nullable": {None: "BtrOPPOREBNullable"}, "non-nullable": {}},
    "LtOPPFT_PCT": {"nullable": {None: "LtOPPFT_PCTNullable"}, "non-nullable": {}},
    "BtrOPPSTL": {"nullable": {None: "BtrOPPSTLNullable"}, "non-nullable": {}},
    "LtOPPAST": {"nullable": {None: "LtOPPASTNullable"}, "non-nullable": {}},
    "BtrOPPREB": {"nullable": {None: "BtrOPPREBNullable"}, "non-nullable": {}},
    "GtOPPPTS": {"nullable": {None: "GtOPPPTSNullable"}, "non-nullable": {}},
    "WrsOPPAST": {"nullable": {None: "WrsOPPASTNullable"}, "non-nullable": {}},
    "WrsOPPOREB": {"nullable": {None: "WrsOPPOREBNullable"}, "non-nullable": {}},
    "BtrOPPPTSFB": {"nullable": {None: "BtrOPPPTSFBNullable"}, "non-nullable": {}},
    "WrsOPPFG3PCT": {"nullable": {None: "WrsOPPFG3PCTNullable"}, "non-nullable": {}},
    "LtOPPFG_PCT": {"nullable": {None: "LtOPPFG_PCTNullable"}, "non-nullable": {}},
    "WrsOPPPF": {"nullable": {None: "WrsOPPPFNullable"}, "non-nullable": {}},
    "LtOPPFTA": {"nullable": {None: "LtOPPFTANullable"}, "non-nullable": {}},
    "BtrOPPFGA": {"nullable": {None: "BtrOPPFGANullable"}, "non-nullable": {}},
    "WrsOPPPTSPAINT": {
        "nullable": {None: "WrsOPPPTSPAINTNullable"},
        "non-nullable": {},
    },
    "GtPTSOFFTOV": {"nullable": {None: "GtPTSOFFTOVNullable"}, "non-nullable": {}},
    "GtOPPPTS2NDCHANCE": {
        "nullable": {None: "GtOPPPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "BtrOPPFG3PCT": {"nullable": {None: "BtrOPPFG3PCTNullable"}, "non-nullable": {}},
    "LtPTSFB": {"nullable": {None: "LtPTSFBNullable"}, "non-nullable": {}},
    "GtOPPREB": {"nullable": {None: "GtOPPREBNullable"}, "non-nullable": {}},
    "LtOPPPF": {"nullable": {None: "LtOPPPFNullable"}, "non-nullable": {}},
    "LtOPPDREB": {"nullable": {None: "LtOPPDREBNullable"}, "non-nullable": {}},
    "WrsOPPFGM": {"nullable": {None: "WrsOPPFGMNullable"}, "non-nullable": {}},
    "GtOPPBLK": {"nullable": {None: "GtOPPBLKNullable"}, "non-nullable": {}},
    "GtOPPFGA": {"nullable": {None: "GtOPPFGANullable"}, "non-nullable": {}},
    "WrsOPPFG_PCT": {"nullable": {None: "WrsOPPFG_PCTNullable"}, "non-nullable": {}},
    "WrsOPPFG3M": {"nullable": {None: "WrsOPPFG3MNullable"}, "non-nullable": {}},
    "BtrOPPTOV": {"nullable": {None: "BtrOPPTOVNullable"}, "non-nullable": {}},
    "BtrOPPFTA": {"nullable": {None: "BtrOPPFTANullable"}, "non-nullable": {}},
    "EqPTSPAINT": {"nullable": {None: "EqPTSPAINTNullable"}, "non-nullable": {}},
    "LtOPPBLK": {"nullable": {None: "LtOPPBLKNullable"}, "non-nullable": {}},
    "BtrOPPFT_PCT": {"nullable": {None: "BtrOPPFT_PCTNullable"}, "non-nullable": {}},
    "LtOPPPTSFB": {"nullable": {None: "LtOPPPTSFBNullable"}, "non-nullable": {}},
    "GtOPPSTL": {"nullable": {None: "GtOPPSTLNullable"}, "non-nullable": {}},
    "GtOPPDREB": {"nullable": {None: "GtOPPDREBNullable"}, "non-nullable": {}},
    "ActiveTeamsOnly": {
        "nullable": {None: "ActiveTeamsOnlyNullable"},
        "non-nullable": {},
    },
    "BtrOPPPTS": {"nullable": {None: "BtrOPPPTSNullable"}, "non-nullable": {}},
    "WrsOPPDREB": {"nullable": {None: "WrsOPPDREBNullable"}, "non-nullable": {}},
    "LtOPPPTSPAINT": {"nullable": {None: "LtOPPPTSPAINTNullable"}, "non-nullable": {}},
    "LtOPPFTM": {"nullable": {None: "LtOPPFTMNullable"}, "non-nullable": {}},
    "WrsOPPFTM": {"nullable": {None: "WrsOPPFTMNullable"}, "non-nullable": {}},
    "EqPTSOFFTOV": {"nullable": {None: "EqPTSOFFTOVNullable"}, "non-nullable": {}},
    "EqOPPPTSFB": {"nullable": {None: "EqOPPPTSFBNullable"}, "non-nullable": {}},
    "BtrOPPAST": {"nullable": {None: "BtrOPPASTNullable"}, "non-nullable": {}},
    "MinGames": {"nullable": {None: "MinGamesNullable"}, "non-nullable": {}},
    "LtOPPFG3M": {"nullable": {None: "LtOPPFG3MNullable"}, "non-nullable": {}},
    "WrsOPPPTS": {"nullable": {None: "WrsOPPPTSNullable"}, "non-nullable": {}},
    "WrsOPPREB": {"nullable": {None: "WrsOPPREBNullable"}, "non-nullable": {}},
    "WrsOPPSTL": {"nullable": {None: "WrsOPPSTLNullable"}, "non-nullable": {}},
    "LtPTSPAINT": {"nullable": {None: "LtPTSPAINTNullable"}, "non-nullable": {}},
    "BtrOPPFG3A": {"nullable": {None: "BtrOPPFG3ANullable"}, "non-nullable": {}},
    "WrsOPPFT_PCT": {"nullable": {None: "WrsOPPFT_PCTNullable"}, "non-nullable": {}},
    "WrsOPPPTSFB": {"nullable": {None: "WrsOPPPTSFBNullable"}, "non-nullable": {}},
    "EqOPPPTSPAINT": {"nullable": {None: "EqOPPPTSPAINTNullable"}, "non-nullable": {}},
    "GtOPPFTM": {"nullable": {None: "GtOPPFTMNullable"}, "non-nullable": {}},
    "GtOPPPTSFB": {"nullable": {None: "GtOPPPTSFBNullable"}, "non-nullable": {}},
    "GtOPPFT_PCT": {"nullable": {None: "GtOPPFT_PCTNullable"}, "non-nullable": {}},
    "LtOPPFG3A": {"nullable": {None: "LtOPPFG3ANullable"}, "non-nullable": {}},
    "GtPTSPAINT": {"nullable": {None: "GtPTSPAINTNullable"}, "non-nullable": {}},
    "WrsOPPTOV": {"nullable": {None: "WrsOPPTOVNullable"}, "non-nullable": {}},
    "BtrOPPPF": {"nullable": {None: "BtrOPPPFNullable"}, "non-nullable": {}},
    "BtrOPPPTS2NDCHANCE": {
        "nullable": {None: "BtrOPPPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "GtOPPPF": {"nullable": {None: "GtOPPPFNullable"}, "non-nullable": {}},
    "WrsOPPFTA": {"nullable": {None: "WrsOPPFTANullable"}, "non-nullable": {}},
    "GtOPPFGM": {"nullable": {None: "GtOPPFGMNullable"}, "non-nullable": {}},
    "LtOPPFG3PCT": {"nullable": {None: "LtOPPFG3PCTNullable"}, "non-nullable": {}},
    "LtOPPREB": {"nullable": {None: "LtOPPREBNullable"}, "non-nullable": {}},
    "WStreak": {"nullable": {None: "WStreakNullable"}, "non-nullable": {}},
    "BtrOPPFTM": {"nullable": {None: "BtrOPPFTMNullable"}, "non-nullable": {}},
    "LtOPPFGA": {"nullable": {None: "LtOPPFGANullable"}, "non-nullable": {}},
    "LtOPPPTSOFFTOV": {
        "nullable": {None: "LtOPPPTSOFFTOVNullable"},
        "non-nullable": {},
    },
    "EqPTS2NDCHANCE": {
        "nullable": {None: "EqPTS2NDCHANCENullable"},
        "non-nullable": {},
    },
    "WrsOPPFG3A": {"nullable": {None: "WrsOPPFG3ANullable"}, "non-nullable": {}},
    "BtrOPPFGM": {"nullable": {None: "BtrOPPFGMNullable"}, "non-nullable": {}},
    "LtOPPOREB": {"nullable": {None: "LtOPPOREBNullable"}, "non-nullable": {}},
    "LtOPPPTS": {"nullable": {None: "LtOPPPTSNullable"}, "non-nullable": {}},
    "LtOPPTOV": {"nullable": {None: "LtOPPTOVNullable"}, "non-nullable": {}},
    "WrsOPPFGA": {"nullable": {None: "WrsOPPFGANullable"}, "non-nullable": {}},
    "GtPTSFB": {"nullable": {None: "GtPTSFBNullable"}, "non-nullable": {}},
    "BtrOPPFG_PCT": {"nullable": {None: "BtrOPPFG_PCTNullable"}, "non-nullable": {}},
    "EqOPPPTSOFFTOV": {
        "nullable": {None: "EqOPPPTSOFFTOVNullable"},
        "non-nullable": {},
    },
    "GtOPPFG3PCT": {"nullable": {None: "GtOPPFG3PCTNullable"}, "non-nullable": {}},
    "EqPTSFB": {"nullable": {None: "EqPTSFBNullable"}, "non-nullable": {}},
    "BtrOPPPTSOFFTOV": {
        "nullable": {None: "BtrOPPPTSOFFTOVNullable"},
        "non-nullable": {},
    },
    "LStreak": {"nullable": {None: "LStreakNullable"}, "non-nullable": {}},
    "GtOPPFG3M": {"nullable": {None: "GtOPPFG3MNullable"}, "non-nullable": {}},
    "DraftNumber": {"nullable": {None: "DraftNumberNullable"}, "non-nullable": {}},
    "YearsExperience": {
        "nullable": {None: "YearsExperienceNullable"},
        "non-nullable": {},
    },
    "DraftTeamID": {"nullable": {None: "DraftTeamIDNullable"}, "non-nullable": {}},
    "DraftRound": {"nullable": {None: "DraftRoundNullable"}, "non-nullable": {}},
    "TwoWay": {"nullable": {None: "TwoWayNullable"}, "non-nullable": {}},
    "MinutesMin": {"nullable": {}, "non-nullable": {None: "MinutesMin"}},
}

def calc_stats(df):
    # Possessions estimate
    df["poss_home"]  df["FGA_home"] + 0.44*df["FTA_home"] - df["OREB_home"] + df["TOV_home"]
    df["poss_away"]  df["FGA_away"] + 0.44*df["FTA_away"] - df["OREB_away"] + df["TOV_away"]

    # Offensive & Defensive Rating
    df["home_ORtg"]  (df["PTS_home"] / df["poss_home"]) * 100
    df["away_ORtg"]  (df["PTS_away"] / df["poss_away"]) * 100

    df["home_DRtg"]  (df["PTS_away"] / df["poss_home"]) * 100
    df["away_DRtg"]  (df["PTS_home"] / df["poss_away"]) * 100

    # eFG%
    df["home_eFG"]  (df["FGM_home"] + 0.5 * df["FG3M_home"]) / df["FGA_home"]
    df["away_eFG"]  (df["FGM_away"] + 0.5 * df["FG3M_away"]) / df["FGA_away"]

    # TOV%
    df["home_TOV"]  df["TOV_home"] / df["poss_home"]
    df["away_TOV"]  df["TOV_away"] / df["poss_away"]

    # Assist Rate
    df["home_AST"]  df["AST_home"] / df["FGM_home"]
    df["away_AST"]  df["AST_away"] / df["FGM_away"]

    # Rebounding %
    df["home_ORB"]  df["OREB_home"] / (df["OREB_home"] + df["DREB_away"])
    df["away_ORB"]  df["OREB_away"] / (df["OREB_away"] + df["DREB_home"])

    df["home_DRB"]  df["DREB_home"] / (df["DREB_home"] + df["OREB_away"])
    df["away_DRB"]  df["DREB_away"] / (df["DREB_away"] + df["OREB_home"])

    # FT Attempt Rate
    df["home_FTAr"]  df["FTA_home"] / df["FGA_home"]
    df["away_FTAr"]  df["FTA_away"] / df["FGA_away"]

    # Home win label
    df["home_win"]  (df["PTS_home"] > df["PTS_away"]).astype(int)

    return df

df.columns

def calc_stats(df):
    # --- Possessions estimate ---
    df["poss_home"]  df["FGA_home"] + 0.44*df["FTA_home"] - df["OREB_home"] + df["TOV_home"]
    df["poss_away"]  df["FGA_away"] + 0.44*df["FTA_away"] - df["OREB_away"] + df["TOV_away"]

    # --- Offensive & Defensive Rating (per 100 possessions) ---
    df["home_ORtg"]  (df["PTS_home"] / df["poss_home"]) * 100
    df["away_ORtg"]  (df["PTS_away"] / df["poss_away"]) * 100

    df["home_DRtg"]  (df["PTS_away"] / df["poss_home"]) * 100
    df["away_DRtg"]  (df["PTS_home"] / df["poss_away"]) * 100

    # --- eFG% ---
    df["home_eFG"]  (df["FGM_home"] + 0.5 * df["FG3M_home"]) / df["FGA_home"]
    df["away_eFG"]  (df["FGM_away"] + 0.5 * df["FG3M_away"]) / df["FGA_away"]

    # --- Turnover Rate (per possession) ---
    df["home_TOV"]  df["TOV_home"] / df["poss_home"]
    df["away_TOV"]  df["TOV_away"] / df["poss_away"]

    # --- Assist Rate (AST per made FG) ---
    df["home_AST"]  df["AST_home"] / df["FGM_home"]
    df["away_AST"]  df["AST_away"] / df["FGM_away"]

    # --- Rebounding % (share of available rebounds) ---
    df["home_ORB"]  df["OREB_home"] / (df["OREB_home"] + df["DREB_away"])
    df["away_ORB"]  df["OREB_away"] / (df["OREB_away"] + df["DREB_home"])

    df["home_DRB"]  df["DREB_home"] / (df["DREB_home"] + df["OREB_away"])
    df["away_DRB"]  df["DREB_away"] / (df["DREB_away"] + df["OREB_home"])

    # --- Free Throw Attempt Rate ---
    df["home_FTAr"]  df["FTA_home"] / df["FGA_home"]
    df["away_FTAr"]  df["FTA_away"] / df["FGA_away"]

    # --- Home win label (target for the model) ---
    df["home_win"]  (df["PTS_home"] > df["PTS_away"]).astype(int)

    return df

df  calc_stats(df)
df[["PTS_home", "PTS_away", "home_ORtg", "away_ORtg", "home_eFG", "home_win"]].head()

df_features  df.copy()

df_features["_ORtg"]  df_features["home_ORtg"] - df_features["away_ORtg"]
df_features["_DRtg"]  df_features["away_DRtg"] - df_features["home_DRtg"]
df_features["_eFG"]   df_features["home_eFG"]  - df_features["away_eFG"]
df_features["_TOV"]   df_features["away_TOV"]  - df_features["home_TOV"]
df_features["_AST"]   df_features["home_AST"]  - df_features["away_AST"]
df_features["_ORB"]   df_features["home_ORB"]  - df_features["away_ORB"]
df_features["_DRB"]   df_features["home_DRB"]  - df_features["away_DRB"]
df_features["_FTAr"]  df_features["home_FTAr"] - df_features["away_FTAr"]

df_features["Home"]  1

feature_cols  [
    "Home",
    "_ORtg",
    "_DRtg",
    "_eFG",
    "_TOV",
    "_AST",
    "_ORB",
    "_DRB",
    "_FTAr",
]

target_col  "home_win"

X  df_features[feature_cols]
y  df_features[target_col]

X.head()

# Build feature dferences (Home  Away or Away  Home depending on direction)
df_features  df.copy()

df_features["_ORtg"]  df_features["home_ORtg"] - df_features["away_ORtg"]
df_features["_DRtg"]  df_features["away_DRtg"] - df_features["home_DRtg"]  # lower DRtg  better
df_features["_eFG"]   df_features["home_eFG"]  - df_features["away_eFG"]
df_features["_TOV"]   df_features["away_TOV"]  - df_features["home_TOV"]   # fewer TOV is better
df_features["_AST"]   df_features["home_AST"]  - df_features["away_AST"]
df_features["_ORB"]   df_features["home_ORB"]  - df_features["away_ORB"]
df_features["_DRB"]   df_features["home_DRB"]  - df_features["away_DRB"]
df_features["_FTAr"]  df_features["home_FTAr"] - df_features["away_FTAr"]

# Home advantage flag
df_features["Home"]  1

# Columns used to train the model
feature_cols  [
    "Home",
    "_ORtg",
    "_DRtg",
    "_eFG",
    "_TOV",
    "_AST",
    "_ORB",
    "_DRB",
    "_FTAr",
]

target_col  "home_win"

# Split into X (features) and y (labels)
X  df_features[feature_cols]
y  df_features[target_col]

X.head()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score

# X and y come from df_features earlier
X_train, X_test, y_train, y_test  train_test_split(
    X, y, test_size0.25, random_state42, stratyy
)

#  Pipeline: scale features then logistic regression
model  make_pipeline(
    StandardScaler(),
    LogisticRegression(max_iter1000)
)

model.fit(X_train, y_train)

probs  model.predict_proba(X_test)[:, 1]
preds  (probs > 0.5).astype(int)

print("Accuracy:", accuracy_score(y_test, preds))
print("ROC AUC:", roc_auc_score(y_test, probs))

coef_table  pd.DataFrame({
    'Feature': feature_cols,
    'Coefficient': model.coef_[0]
}).sort_values("Coefficient", ascendingFalse)

coef_table

import numpy as np

def predict_game(model, home, away):
    row  np.array([[
        1,
        home["ORtg"] - away["ORtg"],
        away["DRtg"] - home["DRtg"],
        home["eFG"] - away["eFG"],
        away["TOV"] - home["TOV"],
        home["AST"] - away["AST"],
        home["ORB"] - away["ORB"],
        home["DRB"] - away["DRB"],
        home["FTAr"] - away["FTAr"],
    ]])
    return model.predict_proba(row)[0,1]

from nba_api.stats.endpoints import leaguedashteamstats
import pandas as pd
import numpy as np

from nba_api.stats.endpoints import leaguedashteamstats

def fetch_team_advanced_stats(season"2024-25"):
    """
    Fetch league-wide team advanced stats for a given season.
    Uses the columns actually returned by your LeagueDashTeamStats.
    """
    stats  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        measure_type_detailed_defense"Advanced",
        per_mode_detailed"PerGame"
    ).get_data_frames()[0]

    # Use only columns that exist in your output
    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
        # no FTA_RATE in your data
    ]

    stats  stats[cols].copy()

    stats.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)

    # We don't have FTAr (FTA_RATE) in this endpoint, so just set to 0 for now.
    # That means _FTAr will be 0 in predictions and won't move the line.
    stats["FTAr"]  0.0

    return stats

import inspect
from nba_api.stats.endpoints import leaguedashteamstats

print(inspect.signature(leaguedashteamstats.LeagueDashTeamStats.__init__))

test  leaguedashteamstats.LeagueDashTeamStats(
    season"2024-25",
    measure_type_detailed_defense"Advanced",
    per_mode_detailed"PerGame"
).get_data_frames()[0]

print(test.columns)

from nba_api.stats.endpoints import leaguedashteamstats

def fetch_team_advanced_stats(season"2024-25"):
    """
    Fetch league-wide team advanced stats for a given season.
    Scales percentage stats to 0-1 range to match training data.
    """
    stats  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        measure_type_detailed_defense"Advanced",
        per_mode_detailed"PerGame"
    ).get_data_frames()[0]

    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]

    stats  stats[cols].copy()

    stats.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)

    #  Scale percentage-like stats to 01  they look like 0100
    for col in ["eFG", "TOV", "AST", "ORB", "DRB"]:
         stats[col].max() > 2:   #  it's like 25, 60, etc.
            stats[col]  stats[col] / 100.0

    # We don't have FTAr, so set to 0 for now
    stats["FTAr"]  0.0

    return stats

team_stats_df  fetch_team_advanced_stats("2024-25")
team_stats_df.head()

def find_team_row(team_name_input, stats_dfteam_stats_df):
    name  team_name_input.strip().lower()

    full_match  stats_df[stats_df["TEAM_NAME"].str.lower()  name]
     not full_match.empty:
        return full_match.iloc[0]

    contains_match  stats_df[stats_df["TEAM_NAME"].str.lower().str.contains(name)]
     not contains_match.empty:
        return contains_match.iloc[0]

    raise ValueError(f"Could not find a team matching: {team_name_input}")

find_team_row("Magic")

import pandas as pd

def build_feature_row_from_teams(home_team_name, away_team_name, stats_dfteam_stats_df):
    home  find_team_row(home_team_name, stats_df)
    away  find_team_row(away_team_name, stats_df)

    home_stats  {
        "ORtg": home["ORtg"],
        "DRtg": home["DRtg"],
        "eFG": home["eFG"],
        "TOV": home["TOV"],
        "AST": home["AST"],
        "ORB": home["ORB"],
        "DRB": home["DRB"],
        "FTAr": home["FTAr"],
    }

    away_stats  {
        "ORtg": away["ORtg"],
        "DRtg": away["DRtg"],
        "eFG": away["eFG"],
        "TOV": away["TOV"],
        "AST": away["AST"],
        "ORB": away["ORB"],
        "DRB": away["DRB"],
        "FTAr": away["FTAr"],
    }

    row  {
        "Home": 1,
        "_ORtg": home_stats["ORtg"] - away_stats["ORtg"],
        "_DRtg": away_stats["DRtg"] - home_stats["DRtg"],
        "_eFG":  home_stats["eFG"]  - away_stats["eFG"],
        "_TOV":  away_stats["TOV"]  - home_stats["TOV"],
        "_AST":  home_stats["AST"]  - away_stats["AST"],
        "_ORB":  home_stats["ORB"]  - away_stats["ORB"],
        "_DRB":  home_stats["DRB"]  - away_stats["DRB"],
        "_FTAr": home_stats["FTAr"] - away_stats["FTAr"],
    }

    # DataFrame with named columns for the pipeline
    feature_df  pd.DataFrame([row], columnsfeature_cols)
    return feature_df, home["TEAM_NAME"], away["TEAM_NAME"]

team_stats_df  fetch_team_advanced_stats("2024-25")
team_stats_df.head()

def predict_matchup(home_team_name, away_team_name, modelmodel, stats_dfteam_stats_df):
    X_row, home_full, away_full  build_feature_row_from_teams(
        home_team_name, away_team_name, stats_df
    )
    prob_home  model.predict_proba(X_row)[0, 1]

    print(f"Matchup: {home_full} (HOME) vs {away_full} (AWAY)")
    print(f"Model home win probability: {prob_home:.3f} ({prob_home*100:.1f}%)")

    return prob_home

def predict_matchup(home_team_name, away_team_name, modelmodel, stats_dfteam_stats_df):
    X_row, home_full, away_full  build_feature_row_from_teams(
        home_team_name, away_team_name, stats_df
    )
    prob_home  model.predict_proba(X_row)[0, 1]

    print(f"Matchup: {home_full} (HOME) vs {away_full} (AWAY)")
    print(f"Raw prob: {prob_home}")  # full precision
    print(f"Model home win probability: {prob_home:.3f} ({prob_home*100:.1f}%)")

    return prob_home

from nba_api.stats.endpoints import leaguedashteamstats
import pandas as pd
import numpy as np

def fetch_team_advanced_stats(season"2024-25"):
    stats  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        measure_type_detailed_defense"Advanced",
        per_mode_detailed"PerGame"
    ).get_data_frames()[0]

    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]

    stats  stats[cols].copy()

    stats.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)

    # Scale percentage-like stats to 01  needed
    for col in ["eFG", "TOV", "ORB", "DRB"]:
         stats[col].max() > 2:
            stats[col]  stats[col] / 100.0

    # AST_PCT is already 0100 or 01 depending on endpoint;
    # check and scale  needed:
     stats["ORB"].max() < 1.0 and stats["DRB"].max() < 1.0 and stats["ORtg"].mean() > 50:
        # heuristic:  ORB/DRB look like proper fractions and ORtg looks normal,
        # then AST_PCT is probably 0100:
         stats["ORB"].max() < 1.0 and stats["DRB"].max() < 1.0 and stats["ORtg"].mean() > 50:
             stats["AST"].max() > 2:
                stats["AST"]  stats["AST"] / 100.0

    # We don't have FTAr, set to 0 for now
    stats["FTAr"]  0.0

    return stats

team_stats_df  fetch_team_advanced_stats("2024-25")
team_stats_df.head()

def find_team_row(team_name_input, stats_dfteam_stats_df):
    name  team_name_input.strip().lower()

    full_match  stats_df[stats_df["TEAM_NAME"].str.lower()  name]
     not full_match.empty:
        return full_match.iloc[0]

    contains_match  stats_df[stats_df["TEAM_NAME"].str.lower().str.contains(name)]
     not contains_match.empty:
        return contains_match.iloc[0]

    raise ValueError(f"Could not find a team matching: {team_name_input}")

def season_matchup_score(home_row, away_row):
    # Extract stats using the columns we just defined/renamed
    h  home_row
    a  away_row

    _ORtg  h["ORtg"] - a["ORtg"]
    _DRtg  a["DRtg"] - h["DRtg"]   # lower DRtg better  flip
    _eFG   h["eFG"]  - a["eFG"]
    _TOV   a["TOV"]  - h["TOV"]   # fewer turnovers is better
    _AST   h["AST"]  - a["AST"]
    _ORB   h["ORB"]  - a["ORB"]
    _DRB   h["DRB"]  - a["DRB"]
    _FTAr  h["FTAr"] - a["FTAr"]

    home_edge  2.0  # base home-court

    score  (
        home_edge
        + 0.08 * _ORtg
        + 0.08 * _DRtg
        + 40.0 * _eFG
        + 30.0 * _TOV
        + 20.0 * _AST
        + 25.0 * _ORB
        + 25.0 * _DRB
        + 10.0 * _FTAr
    )

    return score

def score_to_prob(score, lam0.20):
    # lam controls steepness; 0.2 is a reasonable starting point
    return 1.0 / (1.0 + np.exp(-lam * score))

def predict_season_matchup(home_team_name, away_team_name, stats_dfteam_stats_df):
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    score  season_matchup_score(home_row, away_row)
    prob   score_to_prob(score, lam0.20)

    print(f"Matchup: {home_row['TEAM_NAME']} (HOME) vs {away_row['TEAM_NAME']} (AWAY)")
    print(f"Score (model units): {score:.3f}")
    print(f"Estimated home win probability: {prob:.3f} ({prob*100:.1f}%)")

    return prob

predict_season_matchup("Orlando Magic", "Boston Celtics")
predict_season_matchup("Los Angeles Lakers", "Golden State Warriors")

# How many "points" each type of missing player is worth
INJURY_WEIGHTS  {
    "star": 3.0,      # main offensive/defensive engine
    "starter": 1.5,   # normal starter
    "rotation": 1.0,  # 6th8th man
    "bench": 0.5,     # deep bench
}

def injury_adjustment(home_injuriesNone, away_injuriesNone):
    """
    home_injuries / away_injuries:
      - list of tuples: [("Player Name", "role"), ...]
        where role in {"star", "starter", "rotation", "bench"}
      - or list of dicts: [{"name": "...", "role": "starter"}, ...]

    Missing players on the HOME team LOWER the score.
    Missing players on the AWAY team RAISE the score (helps home).
    """
    home_injuries  home_injuries or []
    away_injuries  away_injuries or []

    def parse_inj_list(lst, sign):
        adj  0.0
        for item in lst:
             isinstance(item, dict):
                role  item.get("role", "starter")
            else:
                # assume tuple like ("Franz Wagner", "starter")
                 len(item) > 2:
                    role  item[1]
                else:
                    role  "starter"
            weight  INJURY_WEIGHTS.get(role, INJURY_WEIGHTS["starter"])
            adj + sign * weight
        return adj

    # Home injuries hurt the home team  negative sign
    # Away injuries hurt the away team  positive for home
    total_adj  0.0
    total_adj + parse_inj_list(home_injuries, sign-1.0)
    total_adj + parse_inj_list(away_injuries, sign+1.0)

    return total_adj

def predict_season_matchup_with_injuries(
    home_team_name,
    away_team_name,
    home_injuriesNone,
    away_injuriesNone,
    stats_dfteam_stats_df,
    lam0.20
):
    # get team rows
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    # base score from stats
    base_score  season_matchup_score(home_row, away_row)
    base_prob   score_to_prob(base_score, lamlam)

    # injury adjustment
    inj_adj     injury_adjustment(home_injuries, away_injuries)
    adj_score   base_score + inj_adj
    adj_prob    score_to_prob(adj_score, lamlam)

    print(f"Matchup: {home_row['TEAM_NAME']} (HOME) vs {away_row['TEAM_NAME']} (AWAY)")
    print(f"Base score: {base_score:.3f}   Base prob: {base_prob:.3f} ({base_prob*100:.1f}%)")
    print(f"Injury adj: {inj_adj:+.3f}   New score: {adj_score:.3f}")
    print(f"Adjusted home win probability: {adj_prob:.3f} ({adj_prob*100:.1f}%)")

    return adj_prob

home_injuries  [
    ("LeBron James", "star"),
]
away_injuries  [
    ("Stephen Curry", "star"),
    ("Draymond Green", "starter"),
]

predict_season_matchup_with_injuries(
    "Los Angeles Lakers",
    "Golden State Warriors",
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

def american_to_implied_prob(odds):
    """
    Convert American moneyline odds to implied probability (before removing vig).
    Example:
      -200 -> 0.666...
      +150 -> 0.4
    """
    odds  float(odds)
     odds < 0:
        return (-odds) / ((-odds) + 100.0)
    else:
        return 100.0 / (odds + 100.0)

def predict_with_injuries_and_odds(
    home_team_name,
    away_team_name,
    home_moneyline,
    away_moneylineNone,
    home_injuriesNone,
    away_injuriesNone,
    stats_dfteam_stats_df,
    lam0.20,
    edge_threshold0.03  # 3 percentage points
):
    # 1) Get base score from stats
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    base_score  season_matchup_score(home_row, away_row)
    base_prob   score_to_prob(base_score, lamlam)

    # 2) Injury adjustment
    inj_adj    injury_adjustment(home_injuries, away_injuries)
    adj_score  base_score + inj_adj
    adj_prob   score_to_prob(adj_score, lamlam)

    # 3) Market implied probabilities from odds
    home_imp_raw  american_to_implied_prob(home_moneyline)

     away_moneyline is not None:
        away_imp_raw  american_to_implied_prob(away_moneyline)
        total  home_imp_raw + away_imp_raw
        # De-vig (normalize so they sum to 1)
        home_imp  home_imp_raw / total
        away_imp  away_imp_raw / total
    else:
        home_imp  home_imp_raw
        away_imp  1.0 - home_imp  # rough approximation

    # 4) Edge
    edge_home  adj_prob - home_imp  # positive  model likes home side

    # 5) Print summary
    print(f"Matchup: {home_row['TEAM_NAME']} (HOME) vs {away_row['TEAM_NAME']} (AWAY)")
    print(f"Base score: {base_score:.3f}   Base prob (home): {base_prob:.3f} ({base_prob*100:.1f}%)")
    print(f"Injury adj: {inj_adj:+.3f}   Adj score: {adj_score:.3f}")
    print(f"Adjusted home win probability: {adj_prob:.3f} ({adj_prob*100:.1f}%)")
    print()
    print(f"Market home moneyline: {home_moneyline}")
     away_moneyline is not None:
        print(f"Market away moneyline: {away_moneyline}")
        print(f"Raw implied probs (home, away): {home_imp_raw:.3f}, {away_imp_raw:.3f}")
        print(f"De-vigged implied probs (home, away): {home_imp:.3f}, {away_imp:.3f}")
    else:
        print(f"Implied home win probability (no de-vig): {home_imp:.3f} ({home_imp*100:.1f}%)")

    print()
    print(f"Model vs market (home):")
    print(f"  Model prob:  {adj_prob:.3f} ({adj_prob*100:.1f}%)")
    print(f"  Market prob: {home_imp:.3f} ({home_imp*100:.1f}%)")
    print(f"  Edge:        {edge_home:+.3f} ({edge_home*100:+.1f} percentage points)")

    # 6) Simple recommendation
     edge_home > edge_threshold:
        print(f"\n  Model says: **VALUE ON HOME** (edge  {edge_threshold:.3f})")
    el edge_home < -edge_threshold:
        print(f"\n  Model says: **VALUE ON AWAY or fade home** (edge  -{edge_threshold:.3f})")
    else:
        print(f"\n  Model says: **NO CLEAR EDGE** (edge smaller than {edge_threshold:.3f})")

    return {
        "home_prob_model": adj_prob,
        "home_prob_market": home_imp,
        "edge_home": edge_home,
    }

predict_with_injuries_and_odds(
    "Orlando Magic",
    "Boston Celtics",
    home_moneyline+180,
    away_moneyline-220,
    home_injuriesNone,
    away_injuriesNone
)

home_injuries  [("Paolo Banchero", "star")]
away_injuries  []

predict_with_injuries_and_odds(
    "Orlando Magic",
    "Boston Celtics",
    home_moneyline+220,
    away_moneyline-270,
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

away_injuries  [
    ("Matisse Thybulle", "rotation"),
    ("Scoot Henderson", "starter"),
    ("Jrue Holiday", "star"),
    ("Blake Wesley", "bench"),
    ("Damian Lillard", "star"),
]

home_injuries  [
    ("Sam Merrill", "bench"),
    ("Max Strus", "starter"),
    ("Jarrett Allen", "star"),
    ("Larry Nance Jr.", "rotation"),
]

pred_blazers_cavs  predict_with_injuries_and_odds(
    home_team_name"Cleveland Cavaliers",
    away_team_name"Portland Trail Blazers",
    home_moneyline-500,
    away_moneyline+350,
    home_injurieshome_injuries,
    away_injuriesaway_injuries,
    edge_threshold0.03
)

pred_blazers_cavs

from nba_api.stats.endpoints import leaguedashteamstats
import pandas as pd
import numpy as np

def fetch_team_advanced_stats(season"2024-25"):
    stats  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        measure_type_detailed_defense"Advanced",
        per_mode_detailed"PerGame"
    ).get_data_frames()[0]

    # Only use the columns we care about
    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]
    stats  stats[cols].copy()

    # Rename to the model's stat keys
    stats.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)

    # Scale % stats to 01  they arrive as 0100
    for col in ["eFG", "TOV", "AST", "ORB", "DRB"]:
         stats[col].max() > 2:
            stats[col]  stats[col] / 100.0

    stats["FTAr"]  0.0  # we don't have this from this endpoint

    return stats

team_stats_df  fetch_team_advanced_stats("2024-25")
print(team_stats_df.columns)
team_stats_df.head()

def score_to_spread(score, points_per_logit1.3):
    """
    Convert model 'score' into predicted point spread.
    Positive  home favorite.

    1.3 is a calibrated value so that:
    - Your score scale
    - Your  in score_to_prob
    - Typical NBA spread  win% relationship
    all roughly line up.
    """
    return score * points_per_logit


def predict_spread(
    home_team_name,
    away_team_name,
    vegas_home_spread,
    home_injuriesNone,
    away_injuriesNone,
    stats_dfteam_stats_df,
    points_per_logit1.3
):
    """
    vegas_home_spread:
      - Positive  home is favored (e.g., Cavs -9.5 > pass 9.5)
      - Negative  home is an underdog (e.g., home +4.0 > pass -4.0)
    """
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    base_score  season_matchup_score(home_row, away_row)
    inj_adj     injury_adjustment(home_injuries, away_injuries)
    adj_score   base_score + inj_adj

    pred_spread  score_to_spread(adj_score, points_per_logit)  # positive  home by X

    edge  pred_spread - vegas_home_spread

    print(f"Matchup: {home_row['TEAM_NAME']} (HOME) vs {away_row['TEAM_NAME']} (AWAY)")
    print(f"Base score: {base_score:.3f}")
    print(f"Injury adj: {inj_adj:+.3f}")
    print(f"Adjusted score: {adj_score:.3f}")
    print(f"Model spread (home): home by {pred_spread:.1f} (home -{pred_spread:.1f})")
    print(f"Vegas spread (home): home by {vegas_home_spread:.1f} (home -{vegas_home_spread:.1f})")
    print(f"Edge vs spread:      {edge:+.2f} points (model - vegas)")

     edge > 1.0:
        print("\n  Model says: **Bet HOME spread**")
    el edge < -1.0:
        print("\n  Model says: **Bet AWAY spread**")
    else:
        print("\n  Model says: **No clear edge** (too close to call)")

    return {
        "pred_spread": pred_spread,
        "edge": edge
    }

# Use the same injury lists we set up earlier:
away_injuries  [
    ("Matisse Thybulle", "rotation"),
    ("Scoot Henderson", "starter"),
    ("Jrue Holiday", "star"),
    ("Blake Wesley", "bench"),
    ("Damian Lillard", "star"),
]

home_injuries  [
    ("Sam Merrill", "bench"),
    ("Max Strus", "starter"),
    ("Jarrett Allen", "star"),
    ("Larry Nance Jr.", "rotation"),
]

# Example Vegas spread: Cavs -9.5 at home
spread_result  predict_spread(
    home_team_name"Cleveland Cavaliers",
    away_team_name"Portland Trail Blazers",
    vegas_home_spread-9.5,
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

spread_result

spread_result  predict_spread(
    home_team_name"Cleveland Cavaliers",
    away_team_name"Portland Trail Blazers",
    vegas_home_spread-9.5,  # Cavs -9.5
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

spread_result

spread_result  predict_spread(
    home_team_name"Cleveland Cavaliers",
    away_team_name"Portland Trail Blazers",
    vegas_home_spread9.5,  # NOT -9.5
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

spread_result

away_injuries  [
    ("Terance Mann", "rotation"),
    ("Haywood Highsmith", "rotation"),
    ("Cam Thomas", "starter"),
]

home_injuries  [
    ("Dalen Terry", "rotation", 0.5),
    ("Lachlan Olbrich", "bench", 0.2),
    ("Julian Phillips", "bench", 0.2),
    ("Noa Essengue", "bench"),
    ("Patrick Williams", "starter", 0.2),
    ("Zach Collins", "starter", 0.5),
    ("Jalen Smith", "starter", 0.5),
    ("Tre Jones", "starter", 0.2),
    ("Kevin Huerter", "starter"),
    ("Coby White", "starter"),
]

pred_nets_bulls  predict_with_injuries_and_odds(
    home_team_name"Chicago Bulls",
    away_team_name"Brooklyn Nets",
    home_moneyline-350,
    away_moneyline+255,
    home_injurieshome_injuries,
    away_injuriesaway_injuries,
    edge_threshold0.03
)

pred_nets_bulls

import pandas as pd

def fetch_injury_report_espn():
    url  "https://www.espn.com/nba/injuries"

    # Grab all tables on page
    tables  pd.read_html(url)
     not tables:
        raise ValueError("read_html found no tables on the ESPN page.")

    injury_tables  []
    for t in tables:
        cols_norm  [str(c).strip().lower() for c in t.columns]
        # Look for something that looks like an injury table:
         any("player" in c or "name" in c for c in cols_norm):
            injury_tables.append(t)

    # Fallback:  our filter didn't find anything, just use all tables
     not injury_tables:
        injury_tables  tables

    df  pd.concat(injury_tables, ignore_indexTrue)

    # Normalize column names
    df.columns  [str(c).strip().title() for c in df.columns]

    # Try to standardize to common names
    rename_map  {}
    for c in df.columns:
        lc  c.lower()
         "player" in lc or "name" in lc:
            rename_map[c]  "Player"
        el "team" in lc:
            rename_map[c]  "Team"
        el "pos" in lc or "position" in lc:
            rename_map[c]  "Pos"
        el "status" in lc:
            rename_map[c]  "Status"
        el "injury" in lc or "reason" in lc:
            rename_map[c]  "Injury"

    df  df.rename(columnsrename_map)

    # Keep only what we care about  present
    keep  [c for c in ["Player", "Team", "Pos", "Status", "Injury"]  c in df.columns]
    df  df[keep].copy()

    return df

# Try it
injury_df  fetch_injury_report_espn()
injury_df.head()

INJURY_ROLE_WEIGHTS  {
    "star": 3.0,
    "starter": 1.5,
    "rotation": 1.0,
    "bench": 0.5,
}

INJURY_STATUS_MULTIPLIER  {
    "out": 1.0,
    "doubtful": 0.75,
    "questionable": 0.5,
    "probable": 0.25,
}

PLAYER_ROLES  {
    # Fill over time with your labels
    "Giannis Antetokounmpo": "star",
    "Damian Lillard": "star",
    "Zach LaVine": "star",
    "Coby White": "starter",
    "Cam Thomas": "starter",
    # ...
}

def guess_role(player_name, pos):
     player_name in PLAYER_ROLES:
        return PLAYER_ROLES[player_name]

    pos  (pos or "").upper()
     pos in ["PG", "SG", "SF", "PF", "G", "F"]:
        return "starter"
    el pos  "C":
        return "starter"
    else:
        return "rotation"

def status_to_mult(status):
     not isinstance(status, str):
        return 1.0
    s  status.lower()
    for key, mult in INJURY_STATUS_MULTIPLIER.items():
         key in s:
            return mult
    # default: treat as fully out
    return 1.0

def build_injury_list_for_team_espn(team_name_or_abbrev, injury_df):
    # ESPN usually uses full team names; we'll match loosely
    team  team_name_or_abbrev.lower()

    #  there's a "Team" column, filter by contains
     "Team" in injury_df.columns:
        mask  injury_df["Team"].astype(str).str.lower().str.contains(team)
        df_team  injury_df[mask].copy()
    else:
        df_team  injury_df.iloc[0:0].copy()  # empty

    injuries  []
    for _, row in df_team.iterrows():
        name  row.get("Player", "")
        pos  row.get("Pos", "")
        status  row.get("Status", "")

        role  guess_role(name, pos)
        mult  status_to_mult(status)

        injuries.append((name, role, mult))

    return injuries

def injury_adjustment(home_injuriesNone, away_injuriesNone):
    home_injuries  home_injuries or []
    away_injuries  away_injuries or []

    def total_weight(inj_list, sign):
        total  0.0
        for item in inj_list:
             len(item)  3:
                _, role, mult  item
            el len(item)  2:
                _, role  item
                mult  1.0
            else:
                continue
            base  INJURY_ROLE_WEIGHTS.get(role, 1.0)
            total + sign * base * mult
        return total

    adj  0.0
    adj + total_weight(home_injuries, sign-1.0)  # hurts home
    adj + total_weight(away_injuries, sign+1.0)  # hurts away (helps home)
    return adj

def build_injuries_for_matchup_espn(home_team_name, away_team_name, injury_df):
    home_inj  build_injury_list_for_team_espn(home_team_name, injury_df)
    away_inj  build_injury_list_for_team_espn(away_team_name, injury_df)

    print(f"Home ({home_team_name}) injuries:")
    for inj in home_inj:
        print(" ", inj)
    print()
    print(f"Away ({away_team_name}) injuries:")
    for inj in away_inj:
        print(" ", inj)

    return home_inj, away_inj

injury_df  fetch_injury_report_espn()

home_injuries, away_injuries  build_injuries_for_matchup_espn(
    "Chicago",    # or "Chicago Bulls"
    "Brooklyn",   # or "Brooklyn Nets"
    injury_df
)

pred_nets_bulls  predict_with_injuries_and_odds(
    home_team_name"Chicago Bulls",
    away_team_name"Brooklyn Nets",
    home_moneyline-350,
    away_moneyline+255,
    home_injurieshome_injuries,
    away_injuriesaway_injuries,
    edge_threshold0.03
)

pred_nets_bulls

spread_result  predict_spread(
    home_team_name"Chicago Bulls",
    away_team_name"Brooklyn Nets",
    vegas_home_spread8.5,   # change this to the real line
    home_injurieshome_injuries,
    away_injuriesaway_injuries
)

spread_result



from nba_api.stats.endpoints import leaguedashteamstats
import pandas as pd

def fetch_team_advanced_stats(season"2024-25"):
    data  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        season_type_all_star"Regular Season",
        per_mode_detailed"PerGame",
        measure_type_detailed_defense"Advanced"   # <-- Correct Param for your NBA API Version
    )

    df  data.get_data_frames()[0]
    return df

team_stats_df  fetch_team_advanced_stats("2024-25")
team_stats_df.head()

import numpy as np

# Use the raw df from nba_api
raw_team_stats_df  team_stats_df.copy()

def prepare_team_stats(df):
    # Keep only the columns we care about
    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]
    df  df[cols].copy()

    # Rename to model-friendly names
    df.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)

    # Scale percentage-like stats to 01  they are 0100
    for col in ["eFG", "TOV", "AST", "ORB", "DRB"]:
         df[col].max() > 2:
            df[col]  df[col] / 100.0

    # Fake FTAr for now
    df["FTAr"]  0.0

    return df

team_stats_df  prepare_team_stats(raw_team_stats_df)
team_stats_df.head()

def find_team_row(team_name_input, stats_dfteam_stats_df):
    name  team_name_input.strip().lower()

    # exact match first
    full_match  stats_df[stats_df["TEAM_NAME"].str.lower()  name]
     not full_match.empty:
        return full_match.iloc[0]

    # contains match (e.g. "Bulls", "Nets")
    contains_match  stats_df[stats_df["TEAM_NAME"].str.lower().str.contains(name)]
     not contains_match.empty:
        return contains_match.iloc[0]

    raise ValueError(f"Could not find a team matching: {team_name_input}")


def season_matchup_score(home_row, away_row):
    h  home_row
    a  away_row

    _ORtg  h["ORtg"] - a["ORtg"]
    _DRtg  a["DRtg"] - h["DRtg"]   # lower DRtg is better
    _eFG   h["eFG"]  - a["eFG"]
    _TOV   a["TOV"]  - h["TOV"]   # fewer TOV is better
    _AST   h["AST"]  - a["AST"]
    _ORB   h["ORB"]  - a["ORB"]
    _DRB   h["DRB"]  - a["DRB"]
    _FTAr  h["FTAr"] - a["FTAr"]

    home_edge  2.0  # base home court

    score  (
        home_edge
        + 0.08 * _ORtg
        + 0.08 * _DRtg
        + 40.0 * _eFG
        + 30.0 * _TOV
        + 20.0 * _AST
        + 25.0 * _ORB
        + 25.0 * _DRB
        + 10.0 * _FTAr
    )

    return score


def score_to_prob(score, lam0.20):
    return 1.0 / (1.0 + np.exp(-lam * score))

INJURY_ROLE_WEIGHTS  {
    "star": 3.0,
    "starter": 1.5,
    "rotation": 1.0,
    "bench": 0.5,
}

def injury_adjustment(home_injuriesNone, away_injuriesNone):
    """
    home_injuries / away_injuries are lists like:
      [("Player Name", "starter"), ("Another Guy", "star"), ...]
     you don't want to use injuries, just pass None or [].
    """
    home_injuries  home_injuries or []
    away_injuries  away_injuries or []

    def total_weight(inj_list, sign):
        total  0.0
        for item in inj_list:
             len(item)  2:
                _, role  item
                mult  1.0
            el len(item)  3:
                _, role, mult  item
            else:
                continue
            base  INJURY_ROLE_WEIGHTS.get(role, 1.0)
            total + sign * base * mult
        return total

    adj  0.0
    # home injuries hurt home
    adj + total_weight(home_injuries, sign-1.0)
    # away injuries hurt away, help home
    adj + total_weight(away_injuries, sign+1.0)

    return adj

def american_to_implied_prob(odds):
    odds  float(odds)
     odds < 0:
        return (-odds) / ((-odds) + 100.0)
    else:
        return 100.0 / (odds + 100.0)

def model_game_prob(
    home_team_name,
    away_team_name,
    home_injuriesNone,
    away_injuriesNone,
    stats_dfteam_stats_df,
    lam0.20
):
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    base_score  season_matchup_score(home_row, away_row)
    inj_adj     injury_adjustment(home_injuries, away_injuries)
    adj_score   base_score + inj_adj
    prob_home   score_to_prob(adj_score, lamlam)

    return prob_home, base_score, inj_adj, adj_score

def run_daily_slate(
    games,
    stats_dfteam_stats_df,
    edge_threshold0.03,
    lam0.20
):
    """
    games: list of dicts or tuples:
      dict: {"home": "Team A", "away": "Team B", "home_ml": -150, "away_ml": +130}
      tuple: ("Team A", "Team B", -150, 130)
    Injuries are optional  for now, we assume none.
    """
    rows  []

    for g in games:
         isinstance(g, dict):
            home  g["home"]
            away  g["away"]
            home_ml  g["home_ml"]
            away_ml  g["away_ml"]
            home_injuries  g.get("home_injuries", None)
            away_injuries  g.get("away_injuries", None)
        else:
            home, away, home_ml, away_ml  g
            home_injuries, away_injuries  None, None

        prob_home, base_score, inj_adj, adj_score  model_game_prob(
            home_team_namehome,
            away_team_nameaway,
            home_injurieshome_injuries,
            away_injuriesaway_injuries,
            stats_dfstats_df,
            lamlam
        )

        # Market implied (de-vigged)
        home_imp_raw  american_to_implied_prob(home_ml)
        away_imp_raw  american_to_implied_prob(away_ml)
        total  home_imp_raw + away_imp_raw
        home_imp  home_imp_raw / total
        away_imp  away_imp_raw / total

        edge_home  prob_home - home_imp
        edge_away  (1 - prob_home) - away_imp

         edge_home > edge_threshold and edge_home > abs(edge_away):
            rec  "Bet HOME ML"
        el edge_away > edge_threshold and edge_away > abs(edge_home):
            rec  "Bet AWAY ML"
            # for convenience
        else:
            rec  "No clear ML edge"

        rows.append({
            "home": home,
            "away": away,
            "home_ml": home_ml,
            "away_ml": away_ml,
            "base_score": base_score,
            "inj_adj": inj_adj,
            "adj_score": adj_score,
            "model_home_prob": prob_home,
            "market_home_prob": home_imp,
            "edge_home": edge_home,
            "edge_away": edge_away,
            "recommendation": rec,
        })

    df  pd.DataFrame(rows)
    df["abs_edge_home"]  df["edge_home"].abs()
    df  df.sort_values("abs_edge_home", ascendingFalse).reset_index(dropTrue)
    return df

games_today  [
    {
        "home": "Chicago Bulls",
        "away": "Brooklyn Nets",
        "home_ml": -350,
        "away_ml": +255,
    },
    {
        "home": "Detroit Pistons",
        "away": "Milwaukee Bucks",
        "home_ml": -206,
        "away_ml": +158,
    },
    {
        "home": "Cleveland Cavaliers",
        "away": "Portland Trail Blazers",
        "home_ml": -500,
        "away_ml": +350,
    },
    # add more games here...
]

slate_df  run_daily_slate(games_today)
slate_df



games_today  [
    {
        "home": "Chicago Bulls",
        "away": "Brooklyn Nets",
        "home_ml": -350,
        "away_ml": +255,
    },
    {
        "home": "Detroit Pistons",
        "away": "Milwaukee Bucks",
        "home_ml": -206,
        "away_ml": +158,
    },
    {
        "home": "Cleveland Cavaliers",
        "away": "Portland Trail Blazers",
        "home_ml": -500,
        "away_ml": +350,
    },
    # add the rest of today's games here...
]

{
    "home": "Orlando Magic",
    "away": "San Antonio Spurs",
    "home_ml": -340,
    "away_ml": +250,
    "home_injuries": [("Paolo Banchero", "star")],
    "away_injuries": [("Victor Wembanyama", "star")],
}

slate_df  run_daily_slate(games_today)
slate_df

from nba_api.stats.endpoints import ScoreboardV2

def fetch_games_for_date(game_date"12/03/2025"):
    """
    game_date format: 'MM/DD/YYYY'
    Returns a DataFrame with home/away team names for that date.
    """
    sb  ScoreboardV2(
        game_dategame_date,
        league_id"00",
        day_offset0
    )

    games_df  sb.get_data_frames()[0]  # 'GameHeader'
    # It has HOME_TEAM_ID and VISITOR_TEAM_ID

    # Map TEAM_ID -> TEAM_NAME from your team_stats_df
    id_to_name  dict(zip(team_stats_df["TEAM_ID"], team_stats_df["TEAM_NAME"]))

    games_df["HOME_TEAM_NAME"]  games_df["HOME_TEAM_ID"].map(id_to_name)
    games_df["AWAY_TEAM_NAME"]  games_df["VISITOR_TEAM_ID"].map(id_to_name)

    # Keep only needed columns
    games_df  games_df[["GAME_ID", "HOME_TEAM_NAME", "AWAY_TEAM_NAME"]]
    return games_df

# Example: today's games (adjust date as needed)
games_today_df  fetch_games_for_date("12/03/2025")
games_today_df

import pandas as pd

def run_daily_probs_for_date(
    game_date"12/03/2025",
    odds_dictNone,          # {(home, away): {"home_ml":..., "away_ml":..., "home_spread":...}} or tuple
    spreads_dictNone,       # OPTIONAL: {(home, away): home_spread}
    stats_dfNone,
    edge_threshold0.03,
    lam0.20,
):
    """
    Run the full model for one NBA date.

    game_date: string in 'MM/DD/YYYY' (for ScoreboardV2), e.g. '12/03/2025'
    odds_dict: optional dict mapping (home, away) ->
               either (home_ml, away_ml) tuple OR
               {"home_ml":..., "away_ml":..., "home_spread":...}
    spreads_dict: optional dict mapping (home, away) -> home_spread (home -X)
    """

    #  Lazy default: grab the global team_stats_df *at call time*, not def time
     stats_df is None:
        try:
            stats_df  team_stats_df
        except NameError:
            raise RuntimeError(
                "team_stats_df is not defined yet. "
                "Run the cell that builds team_stats_df before calling run_daily_probs_for_date."
            )

    games_df  fetch_games_for_date(game_date)

    rows  []

    for _, row in games_df.iterrows():
        home  row["HOME_TEAM_NAME"]
        away  row["AWAY_TEAM_NAME"]

        # ---------- Moneyline odds (optional) ----------
        home_ml  None
        away_ml  None
        home_spread  None

         odds_dict is not None and (home, away) in odds_dict:
            val  odds_dict[(home, away)]
             isinstance(val, dict):
                home_ml  val.get("home_ml", None)
                away_ml  val.get("away_ml", None)
                home_spread  val.get("home_spread", None)
            else:
                # assume (home_ml, away_ml) tuple
                home_ml, away_ml  val

        # ---------- Spread dict override (optional) ----------
         spreads_dict is not None and (home, away) in spreads_dict:
            home_spread  spreads_dict[(home, away)]

        # ---------- Core model ----------
        prob_home, base_score, inj_adj, adj_score  model_game_prob(
            home_team_namehome,
            away_team_nameaway,
            home_injuriesNone,
            away_injuriesNone,
            stats_dfstats_df,
            lamlam,
        )

        # Model spread (home favorite by X)
        model_spread_home  score_to_spread(adj_score)

        record  {
            "home": home,
            "away": away,
            "model_home_prob": prob_home,
            "base_score": base_score,
            "inj_adj": inj_adj,
            "adj_score": adj_score,
            "model_spread_home": model_spread_home,
        }

        # ---------- Moneyline edges ----------
         home_ml is not None and away_ml is not None:
            home_imp_raw  american_to_implied_prob(home_ml)
            away_imp_raw  american_to_implied_prob(away_ml)
            total  home_imp_raw + away_imp_raw
            home_imp  home_imp_raw / total
            away_imp  away_imp_raw / total

            edge_home  prob_home - home_imp
            edge_away  (1.0 - prob_home) - away_imp

            record.update({
                "home_ml": home_ml,
                "away_ml": away_ml,
                "market_home_prob": home_imp,
                "edge_home": edge_home,
                "edge_away": edge_away,
            })

        # ---------- Spread edge ----------
         home_spread is not None:
            spread_edge  model_spread_home - home_spread
            record.update({
                "home_spread": home_spread,
                "spread_edge_home": spread_edge,
            })

        rows.append(record)

    df  pd.DataFrame(rows)

     "edge_home" in df.columns:
        df["abs_edge_home"]  df["edge_home"].abs()
        df  df.sort_values("abs_edge_home", ascendingFalse).reset_index(dropTrue)

    return df

"""ffrom datetime import datetime, timedelta

def run_x_days_stats(
    num_days,
    start_dateNone,      # "YYYY-MM-DD"
    odds_by_dateNone,    # {"YYYY-MM-DD": odds_dict}
    spreads_by_dateNone, # {"YYYY-MM-DD": spreads_dict}
    edge_threshold0.03,
    lam0.20,
    stats_dfNone,
    injury_dfNone,       # NEW
):
     stats_df is None:
        stats_df  team_stats_df

    #  no injury_df passed, grab once now
     injury_df is None:
        try:
            injury_df  fetch_injury_report_espn()
        except Exception as e:
            print(f" Could not fetch ESPN injuries, running without injuries: {e}")
            injury_df  None

     start_date is None:
        current_date  datetime.today().date()
    else:
        current_date  datetime.strptime(start_date, "%Y-%m-%d").date()

    all_results  {}

    for i in range(num_days):
        day  current_date + timedelta(daysi)
        date_iso  day.strftime("%Y-%m-%d")   # for dict keys
        date_nba  day.strftime("%m/%d/%Y")   # for ScoreboardV2

        print("\n")
        print(f"Running stats for {date_iso}")
        print("")

        odds_dict  odds_by_date.get(date_iso)  odds_by_date else None
        spreads_dict  spreads_by_date.get(date_iso)  spreads_by_date else None

        try:
            df  run_daily_probs_for_date(
                game_datedate_nba,
                odds_dictodds_dict,
                spreads_dictspreads_dict,
                stats_dfstats_df,
                edge_thresholdedge_threshold,
                lamlam,
                injury_dfinjury_df,   # <-- HERE
            )
            all_results[date_iso]  df
            display(df)
        except Exception as e:
            print(f" Error running for {date_iso}: {e}")

    return all_results

"""

full_day_df  run_daily_probs_for_date("12/03/2025", odds_dictNone)
full_day_df

odds_today  {
    ("Chicago Bulls", "Brooklyn Nets"): (-350, +255),
    ("Detroit Pistons", "Milwaukee Bucks"): (-206, +158),
    ("Cleveland Cavaliers", "Portland Trail Blazers"): (-500, +350),
    # add the rest of todays games here  you have odds
}

full_day_with_edges  run_daily_probs_for_date(
    "12/03/2025",
    odds_dictodds_today
)
full_day_with_edges

odds_today  {
    ("Chicago Bulls", "Brooklyn Nets"): (-350, +255),
    ("Cleveland Cavaliers", "Portland Trail Blazers"): (-500, +350),
    ("Indiana Pacers", "Denver Nuggets"): (+120, -140),      # <-- fill real line
    ("Orlando Magic", "San Antonio Spurs"): (-340, +250),
    ("Atlanta Hawks", "LA Clippers"): (-110, -110),
    ("New York Knicks", "Charlotte Hornets"): (-400, +310),
    ("Houston Rockets", "Sacramento Kings"): (-130, +110),
    ("Milwaukee Bucks", "Detroit Pistons"): (-206, +158),
    ("Dallas Mavericks", "Miami Heat"): (-115, -105),
}

full_day_with_edges  run_daily_probs_for_date(
    "12/03/2025",
    odds_dictodds_today
)

full_day_with_edges

def score_to_spread(score, points_per_logit1.3):
    """
    Convert model 'score' into predicted point spread.
    Positive  home favorite by that many points (home -spread).
    Example: +5.5  > model thinks home should be -5.5
    """
    return score * points_per_logit

import pandas as pd

def run_daily_probs_for_date(
    game_date"12/03/2025",
    odds_dictNone,          # {(home, away): {"home_ml":..., "away_ml":..., "home_spread":...}} or tuple
    spreads_dictNone,       # OPTIONAL: {(home, away): home_spread}
    stats_dfNone,
    edge_threshold0.03,
    lam0.20,
):
    """
    Run the full model for one NBA date.

    game_date: string in 'MM/DD/YYYY' (for ScoreboardV2), e.g. '12/03/2025'
    odds_dict: optional dict mapping (home, away) ->
               either (home_ml, away_ml) tuple OR
               {"home_ml":..., "away_ml":..., "home_spread":...}
    spreads_dict: optional dict mapping (home, away) -> home_spread (home -X)
    """

    #  Lazy default: grab the global team_stats_df *at call time*, not def time
     stats_df is None:
        try:
            stats_df  team_stats_df
        except NameError:
            raise RuntimeError(
                "team_stats_df is not defined yet. "
                "Run the cell that builds team_stats_df before calling run_daily_probs_for_date."
            )

    games_df  fetch_games_for_date(game_date)

    rows  []

    for _, row in games_df.iterrows():
        home  row["HOME_TEAM_NAME"]
        away  row["AWAY_TEAM_NAME"]

        # ---------- Moneyline odds (optional) ----------
        home_ml  None
        away_ml  None
        home_spread  None

         odds_dict is not None and (home, away) in odds_dict:
            val  odds_dict[(home, away)]
             isinstance(val, dict):
                home_ml  val.get("home_ml", None)
                away_ml  val.get("away_ml", None)
                home_spread  val.get("home_spread", None)
            else:
                # assume (home_ml, away_ml) tuple
                home_ml, away_ml  val

        # ---------- Spread dict override (optional) ----------
         spreads_dict is not None and (home, away) in spreads_dict:
            home_spread  spreads_dict[(home, away)]

        # ---------- Core model ----------
        prob_home, base_score, inj_adj, adj_score  model_game_prob(
            home_team_namehome,
            away_team_nameaway,
            home_injuriesNone,
            away_injuriesNone,
            stats_dfstats_df,
            lamlam,
        )

        # Model spread (home favorite by X)
        model_spread_home  score_to_spread(adj_score)

        record  {
            "home": home,
            "away": away,
            "model_home_prob": prob_home,
            "base_score": base_score,
            "inj_adj": inj_adj,
            "adj_score": adj_score,
            "model_spread_home": model_spread_home,
        }

        # ---------- Moneyline edges ----------
         home_ml is not None and away_ml is not None:
            home_imp_raw  american_to_implied_prob(home_ml)
            away_imp_raw  american_to_implied_prob(away_ml)
            total  home_imp_raw + away_imp_raw
            home_imp  home_imp_raw / total
            away_imp  away_imp_raw / total

            edge_home  prob_home - home_imp
            edge_away  (1.0 - prob_home) - away_imp

            record.update({
                "home_ml": home_ml,
                "away_ml": away_ml,
                "market_home_prob": home_imp,
                "edge_home": edge_home,
                "edge_away": edge_away,
            })

        # ---------- Spread edge ----------
         home_spread is not None:
            spread_edge  model_spread_home - home_spread
            record.update({
                "home_spread": home_spread,
                "spread_edge_home": spread_edge,
            })

        rows.append(record)

    df  pd.DataFrame(rows)

     "edge_home" in df.columns:
        df["abs_edge_home"]  df["edge_home"].abs()
        df  df.sort_values("abs_edge_home", ascendingFalse).reset_index(dropTrue)

    return df

spreads_today  {
    ("Chicago Bulls", "Brooklyn Nets"): 8.5,   # Bulls -8.5
    ("Cleveland Cavaliers", "Portland Trail Blazers"): 9.5,  # Cavs -9.5
    # etc for other games...
}

full_day_with_spreads  run_daily_probs_for_date(
    "12/03/2025",
    odds_dictodds_today,        # your ML dict from before (optional)
    spreads_dictspreads_today   # new
)

full_day_with_spreads

odds_today  {
    ("Chicago Bulls", "Brooklyn Nets"): {
        "home_ml": -350,
        "away_ml": +255,
        "home_spread": 8.5,   # Bulls -8.5
    },
    ("Cleveland Cavaliers", "Portland Trail Blazers"): {
        "home_ml": -500,
        "away_ml": +350,
        "home_spread": 9.5,   # Cavs -9.5
    },
    # etc for all games
}

def score_to_spread(score, points_per_logit1.3):
    """
    Convert model 'score' into predicted point spread.
    Positive  home favorite by that many points (home -spread).
    """
    return score * points_per_logit

odds_today  {
    ("Chicago Bulls", "Brooklyn Nets"): {
        "home_ml": -350,
        "away_ml": +255,
        "home_spread": 8.5,   # Bulls -8.5
    },
    ("Cleveland Cavaliers", "Portland Trail Blazers"): {
        "home_ml": -500,
        "away_ml": +350,
        "home_spread": 9.5,   # Cavs -9.5
    },
    # add more...
}

full_day  run_daily_probs_for_date(
    "12/03/2025",
    odds_dictodds_today
)

full_day

def spread_recommendation(row, spread_edge_threshold1.5):
    """
    spread_edge_home  model_spread_home - home_spread
    Positive   model thinks home should be more favored  bet home spread
    Negative   model thinks home should be less favored  bet away spread
    """
    se  row.get("spread_edge_home", np.nan)
     pd.isna(se):
        return "No spread line"

     se > spread_edge_threshold:
        return "Bet HOME spread"
    el se < -spread_edge_threshold:
        return "Bet AWAY spread"
    else:
        return "No clear spread edge"

full_day["spread_recommendation"]  full_day.apply(spread_recommendation, axis1)
full_day

print("Games from NBA schedule:")
for _, row in fetch_games_for_date("12/03/2025").iterrows():
    key  (row["HOME_TEAM_NAME"], row["AWAY_TEAM_NAME"])
    print(key)

print("\nKeys you have in odds_today:")
for key in odds_today.keys():
    print(key)

odds_today  {
    ("Chicago Bulls", "Brooklyn Nets"): {
        "home_ml": -350,
        "away_ml": 255,
        "home_spread": 8.5,   # Bulls -8.5
    },
    ("Cleveland Cavaliers", "Portland Trail Blazers"): {
        "home_ml": -500,
        "away_ml": 350,
        "home_spread": 9.5,   # Cavs -9.5
    },
    ("Indiana Pacers", "Denver Nuggets"): {
        "home_ml": 120,       # example numbers  replace with real lines
        "away_ml": -140,
        "home_spread": 2.5,   # Pacers +2.5  enter 2.5  book says Nuggets -2.5
    },
    ("Orlando Magic", "San Antonio Spurs"): {
        "home_ml": -340,
        "away_ml": 250,
        "home_spread": 7.5,
    },
    ("Atlanta Hawks", "LA Clippers"): {
        "home_ml": -110,
        "away_ml": -110,
        "home_spread": 1.5,
    },
    ("New York Knicks", "Charlotte Hornets"): {
        "home_ml": -400,
        "away_ml": 310,
        "home_spread": 9.0,
    },
    ("Houston Rockets", "Sacramento Kings"): {
        "home_ml": -130,
        "away_ml": 110,
        "home_spread": 3.0,
    },
    ("Milwaukee Bucks", "Detroit Pistons"): {
        "home_ml": -206,
        "away_ml": 158,
        "home_spread": 5.5,
    },
    ("Dallas Mavericks", "Miami Heat"): {
        "home_ml": -115,
        "away_ml": -105,
        "home_spread": 2.0,
    },
}

full_day  run_daily_probs_for_date(
    "12/03/2025",
    odds_dictodds_today
)

full_day

full_day[["home", "away", "home_spread", "model_spread_home", "spread_edge_home"]]

def spread_recommendation(row, threshold1.5):
    se  row["spread_edge_home"]
     se > threshold:
        return "Bet HOME spread"
    el se < -threshold:
        return "Bet AWAY spread"
    else:
        return "No clear spread edge"

full_day["spread_recommendation"]  full_day.apply(spread_recommendation, axis1)
full_day[["home", "away", "home_spread", "model_spread_home", "spread_edge_home", "spread_recommendation"]]

import numpy as np
import pandas as pd

def ml_recommendation(row, ml_edge_threshold0.03):
    """
    Decide ML side for one game.
    Uses:
      edge_home (model - market for home)
      edge_away (model - market for away)
    Threshold is in probability (0.03  3%).
    """
     "edge_home" not in row or pd.isna(row["edge_home"]):
        return "No ML odds"

    eh  row["edge_home"]
    ea  row.get("edge_away", None)

    # default away edge from home edge  missing
     ea is None or pd.isna(ea):
         "market_home_prob" in row and not pd.isna(row["market_home_prob"]):
            ea  (1 - row["model_home_prob"]) - (1 - row["market_home_prob"])
        else:
            ea  -eh

     eh > ml_edge_threshold and eh > abs(ea):
        return f"Bet HOME ML ({row['home_ml']:+})"
    el ea > ml_edge_threshold and ea > abs(eh):
        return f"Bet AWAY ML ({row['away_ml']:+})"
    else:
        return "No clear ML edge"

full_day["ml_recommendation"]  full_day.apply(ml_recommendation, axis1)

def spread_recommendation(row, spread_edge_threshold1.5):
    """
    spread_edge_home  model_spread_home - home_spread
    Positive   model thinks home should be more favored  bet home spread
    Negative   model thinks home should be less favored  bet away spread
    Threshold in points (e.g. 1.5  need 1.5 pts of edge).
    """
    se  row.get("spread_edge_home", np.nan)
    hs  row.get("home_spread", np.nan)

     pd.isna(se) or pd.isna(hs):
        return "No spread line"

     se > spread_edge_threshold:
        return f"Bet HOME spread (home -{hs})"
    el se < -spread_edge_threshold:
        return f"Bet AWAY spread (away +{hs})"
    else:
        return "No clear spread edge"

full_day["spread_recommendation"]  full_day.apply(spread_recommendation, axis1)

def best_bet_for_row(row, ml_edge_threshold0.03, spread_edge_threshold1.5):
    """
    Decide the single best bet for a game, choosing between:
      - ML (home or away)
      - Spread (home or away)
      - Or 'No clear edge'
    """
    # --- ML edges ---
    ml_side  "none"
    ml_edge_val  0.0

     "edge_home" in row and not pd.isna(row["edge_home"]):
        eh  row["edge_home"]
        ea  row.get("edge_away", None)
         ea is None or pd.isna(ea):
             "market_home_prob" in row and not pd.isna(row["market_home_prob"]):
                ea  (1 - row["model_home_prob"]) - (1 - row["market_home_prob"])
            else:
                ea  -eh

         eh > ml_edge_threshold and eh > abs(ea):
            ml_side  "HOME_ML"
            ml_edge_val  eh
        el ea > ml_edge_threshold and ea > abs(eh):
            ml_side  "AWAY_ML"
            ml_edge_val  ea

    # --- Spread edges ---
    spread_side  "none"
    spread_edge_val  0.0
    se  row.get("spread_edge_home", np.nan)
    hs  row.get("home_spread", np.nan)

     not pd.isna(se) and not pd.isna(hs):
         se > spread_edge_threshold:
            spread_side  "HOME_SPREAD"
            spread_edge_val  se
        el se < -spread_edge_threshold:
            spread_side  "AWAY_SPREAD"
            spread_edge_val  abs(se)  # use absolute edge for comparison

    # --- Compare edges ---
    # We compare absolute edges: bigger edge wins
     ml_side  "none" and spread_side  "none":
        return "No clear edge"
    el spread_side  "none" and spread_edge_val > abs(ml_edge_val)):
        # Take spread bet
         spread_side  "HOME_SPREAD":
            return f"BEST: HOME spread (home -{hs})"
        else:
            return f"BEST: AWAY spread (away +{hs})"
    else:
        # Take ML bet
         ml_side  "HOME_ML":
            return f"BEST: HOME ML ({row['home_ml']:+})"
        else:
            return f"BEST: AWAY ML ({row['away_ml']:+})"

def best_bet_for_row(row, ml_edge_threshold0.03, spread_edge_threshold1.5):
    """
    Decide the single best bet for a game, choosing between:
      - ML (home or away)
      - Spread (home or away)
      - Or 'No clear edge'
    """
    # --- ML edges ---
    ml_side  "none"
    ml_edge_val  0.0

     "edge_home" in row and not pd.isna(row["edge_home"]):
        eh  row["edge_home"]
        ea  row.get("edge_away", None)
         ea is None or pd.isna(ea):
             "market_home_prob" in row and not pd.isna(row["market_home_prob"]):
                ea  (1 - row["model_home_prob"]) - (1 - row["market_home_prob"])
            else:
                ea  -eh

         eh > ml_edge_threshold and eh > abs(ea):
            ml_side  "HOME_ML"
            ml_edge_val  eh
        el ea > ml_edge_threshold and ea > abs(eh):
            ml_side  "AWAY_ML"
            ml_edge_val  ea

    # --- Spread edges ---
    spread_side  "none"
    spread_edge_val  0.0
    se  row.get("spread_edge_home", np.nan)
    hs  row.get("home_spread", np.nan)

     not pd.isna(se) and not pd.isna(hs):
         se > spread_edge_threshold:
            spread_side  "HOME_SPREAD"
            spread_edge_val  se
        el se < -spread_edge_threshold:
            spread_side  "AWAY_SPREAD"
            spread_edge_val  abs(se)

    # --- Compare edges ---
     ml_side  "none" and spread_side  "none":
        return "No clear edge"
    el spread_side  "none" and spread_edge_val > abs(ml_edge_val):
         spread_side  "HOME_SPREAD":
            return f"BEST: HOME spread (home -{hs})"
        else:
            return f"BEST: AWAY spread (away +{hs})"
    else:
         ml_side  "HOME_ML":
            return f"BEST: HOME ML ({row['home_ml']:+})"
        else:
            return f"BEST: AWAY ML ({row['away_ml']:+})"

full_day["best_bet"]  full_day.apply(best_bet_for_row, axis1)

full_day[[
    "home", "away",
    "home_ml", "away_ml",
    "home_spread", "model_home_prob", "model_spread_home",
    "ml_recommendation", "spread_recommendation", "best_bet"
]]

from datetime import datetime, timedelta

def run_x_days_stats(num_days, start_dateNone):
    """
    Run your daily model for `num_days` days in a row.

    - num_days: int, how many days of stats to run
    - start_date: "YYYY-MM-DD" (optional).  None, start from today.
    """
     start_date is None:
        current_date  datetime.today()
    else:
        current_date  datetime.strptime(start_date, "%Y-%m-%d")

    all_results  {}

    for i in range(num_days):
        game_date  (current_date + timedelta(daysi)).strftime("%Y-%m-%d")
        print(f"\n")
        print(f"Running stats for {game_date}")
        print(f"")

        try:
            #  This assumes you already have a function like:
            #     run_daily_card(game_date_str)
            # that returns a DataFrame OR some result object.
            daily_results  run_daily_card(game_date)

            # Save results in a dict keyed by date
            all_results[game_date]  daily_results

            #  it's a DataFrame, this will show it nicely in Colab
            try:
                display(daily_results)
            except NameError:
                #  display isn't imported yet, just print
                print(daily_results)

        except Exception as e:
            print(f" Error running for {game_date}: {e}")

    return all_results

import pandas as pd

def run_daily_card(game_date_str):
    """
    Run your model for every game on a given date.
    Returns a DataFrame of results.
    """

    #  This assumes you already built a DataFrame of games called games_df
    # with at least these columns: "GAME_DATE", "HOME_TEAM", "AWAY_TEAM", "VEGAS_SPREAD"
    # Adjust the column names to match your actual data.
    day_games  games_df[games_df["GAME_DATE"]  game_date_str]

    results  []

    for _, g in day_games.iterrows():
        #  Call your existing per-game function here.
        # Replace arguments to match your real predict_spread signature.
        model_output  predict_spread(
            home_team_nameg["HOME_TEAM"],
            away_team_nameg["AWAY_TEAM"],
            vegas_home_spreadg["VEGAS_SPREAD"],
            # add injuries / stats here  your function needs them
            # home_injuries..., away_injuries...,
            # home_team_stats..., away_team_stats...,
        )

        #  Build a row for the results table
        results.append({
            "date": game_date_str,
            "home_team": g["HOME_TEAM"],
            "away_team": g["AWAY_TEAM"],
            "vegas_spread": g["VEGAS_SPREAD"],
            #  model_output is a dict, you can unpack it:
            **(model_output  isinstance(model_output, dict) else {"model_output": model_output}),
        })

    results_df  pd.DataFrame(results)
    return results_df


#  IMPORTS 
import pandas as pd
import numpy as np
from nba_api.stats.endpoints import leaguedashteamstats

#  TEAM STATS 

def fetch_team_advanced_stats(season"2024-25"):
    data  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        season_type_all_star"Regular Season",
        per_mode_detailed"PerGame",
        measure_type_detailed_defense"Advanced"   # works in your nba_api
    )
    return data.get_data_frames()[0]

raw_team_stats_df  fetch_team_advanced_stats("2024-25")

def prepare_team_stats(df):
    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]
    df  df[cols].copy()
    df.rename(columns{
        "OFF_RATING": "ORtg",
        "DEF_RATING": "DRtg",
        "EFG_PCT": "eFG",
        "TM_TOV_PCT": "TOV",
        "AST_PCT": "AST",
        "OREB_PCT": "ORB",
        "DREB_PCT": "DRB",
    }, inplaceTrue)
    for col in ["eFG", "TOV", "AST", "ORB", "DRB"]:
         df[col].max() > 2:
            df[col]  df[col] / 100.0
    df["FTAr"]  0.0
    return df

team_stats_df  prepare_team_stats(raw_team_stats_df)

#  CORE MODEL HELPERS 

def find_team_row(team_name_input, stats_dfteam_stats_df):
    name  team_name_input.strip().lower()
    full_match  stats_df[stats_df["TEAM_NAME"].str.lower()  name]
     not full_match.empty:
        return full_match.iloc[0]
    contains_match  stats_df[stats_df["TEAM_NAME"].str.lower().str.contains(name)]
     not contains_match.empty:
        return contains_match.iloc[0]
    raise ValueError(f"Could not find a team matching: {team_name_input}")

def season_matchup_score(home_row, away_row):
    h  home_row
    a  away_row

    _ORtg  h["ORtg"] - a["ORtg"]
    _DRtg  a["DRtg"] - h["DRtg"]
    _eFG   h["eFG"]  - a["eFG"]
    _TOV   a["TOV"]  - h["TOV"]
    _AST   h["AST"]  - a["AST"]
    _ORB   h["ORB"]  - a["ORB"]
    _DRB   h["DRB"]  - a["DRB"]
    _FTAr  h["FTAr"] - a["FTAr"]

    home_edge  2.0

    score  (
        home_edge
        + 0.08 * _ORtg
        + 0.08 * _DRtg
        + 40.0 * _eFG
        + 30.0 * _TOV
        + 20.0 * _AST
        + 25.0 * _ORB
        + 25.0 * _DRB
        + 10.0 * _FTAr
    )
    return score

def score_to_prob(score, lam0.20):
    return 1.0 / (1.0 + np.exp(-lam * score))

#  INJURIES (simple roles; injuries optional) 

INJURY_ROLE_WEIGHTS  {
    "star": 3.0,
    "starter": 1.5,
    "rotation": 1.0,
    "bench": 0.5,
}

def injury_adjustment(home_injuriesNone, away_injuriesNone):
    """
    home_injuries / away_injuries:
      list like [("Player Name", "starter"), ("Guy", "rotation"), ...]
      or ("Player", "starter", 0.5)  you want partial weight.
    """
    home_injuries  home_injuries or []
    away_injuries  away_injuries or []

    def total_weight(inj_list, sign):
        total  0.0
        for item in inj_list:
             len(item)  3:
                _, role, mult  item
            el len(item)  2:
                _, role  item
                mult  1.0
            else:
                continue
            base  INJURY_ROLE_WEIGHTS.get(role, 1.0)
            total + sign * base * mult
        return total

    adj  0.0
    adj + total_weight(home_injuries, sign-1.0)  # hurts home
    adj + total_weight(away_injuries, sign+1.0)  # hurts away
    return adj

def american_to_implied_prob(odds):
    odds  float(odds)
     odds < 0:
        return (-odds) / ((-odds) + 100.0)
    else:
        return 100.0 / (odds + 100.0)

def model_game_prob(
    home_team_name,
    away_team_name,
    home_injuriesNone,
    away_injuriesNone,
    stats_dfteam_stats_df,
    lam0.20
):
    home_row  find_team_row(home_team_name, stats_df)
    away_row  find_team_row(away_team_name, stats_df)

    base_score  season_matchup_score(home_row, away_row)
    inj_adj     injury_adjustment(home_injuries, away_injuries)
    adj_score   base_score + inj_adj
    prob_home   score_to_prob(adj_score, lamlam)

    return prob_home, base_score, inj_adj, adj_score

#  DAILY SLATE RUNNER 

def run_daily_slate(
    games,
    stats_dfteam_stats_df,
    edge_threshold0.03,
    lam0.20
):
    """
    games: list of dicts or tuples:
      dict: {"home": "Team A", "away": "Team B", "home_ml": -150, "away_ml": +130,
             "home_injuries": [...], "away_injuries": [...]}
      tuple: ("Team A", "Team B", -150, 130)
    """
    rows  []

    for g in games:
         isinstance(g, dict):
            home  g["home"]
            away  g["away"]
            home_ml  g["home_ml"]
            away_ml  g["away_ml"]
            home_injuries  g.get("home_injuries", None)
            away_injuries  g.get("away_injuries", None)
        else:
            home, away, home_ml, away_ml  g
            home_injuries, away_injuries  None, None

        prob_home, base_score, inj_adj, adj_score  model_game_prob(
            home_team_namehome,
            away_team_nameaway,
            home_injurieshome_injuries,
            away_injuriesaway_injuries,
            stats_dfstats_df,
            lamlam
        )

        home_imp_raw  american_to_implied_prob(home_ml)
        away_imp_raw  american_to_implied_prob(away_ml)
        total  home_imp_raw + away_imp_raw
        home_imp  home_imp_raw / total
        away_imp  away_imp_raw / total

        edge_home  prob_home - home_imp
        edge_away  (1 - prob_home) - away_imp

         edge_home > edge_threshold and edge_home > abs(edge_away):
            rec  "Bet HOME ML"
        el edge_away > edge_threshold and edge_away > abs(edge_home):
            rec  "Bet AWAY ML"
        else:
            rec  "No clear ML edge"

        rows.append({
            "home": home,
            "away": away,
            "home_ml": home_ml,
            "away_ml": away_ml,
            "base_score": base_score,
            "inj_adj": inj_adj,
            "adj_score": adj_score,
            "model_home_prob": prob_home,
            "market_home_prob": home_imp,
            "edge_home": edge_home,
            "edge_away": edge_away,
            "recommendation": rec,
        })

    df  pd.DataFrame(rows)
    df["abs_edge_home"]  df["edge_home"].abs()
    df  df.sort_values("abs_edge_home", ascendingFalse).reset_index(dropTrue)
    return df

from nba_api.stats.endpoints import leaguedashteamstats
import pandas as pd
import numpy as np

def fetch_team_advanced_stats_raw(season"2024-25"):
    """
    Get the raw advanced team stats from nba_api.
    """
    data  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        season_type_all_star"Regular Season",
        per_mode_detailed"PerGame",
        measure_type_detailed_defense"Advanced",
    )
    df  data.get_data_frames()[0]
    return df

def prepare_team_stats(df):
    """
    Keep only needed columns and rename them to the names your model expects:
      ORtg, DRtg, eFG, TOV, AST, ORB, DRB, FTAr
    """
    cols  [
        "TEAM_ID",
        "TEAM_NAME",
        "OFF_RATING",
        "DEF_RATING",
        "EFG_PCT",
        "TM_TOV_PCT",
        "AST_PCT",
        "OREB_PCT",
        "DREB_PCT",
    ]
    df  df[cols].copy()

    df.rename(
        columns{
            "OFF_RATING": "ORtg",
            "DEF_RATING": "DRtg",
            "EFG_PCT": "eFG",
            "TM_TOV_PCT": "TOV",
            "AST_PCT": "AST",
            "OREB_PCT": "ORB",
            "DREB_PCT": "DRB",
        },
        inplaceTrue,
    )

    # Scale percentage-like stats from 0100 to 01  needed
    for col in ["eFG", "TOV", "AST", "ORB", "DRB"]:
         df[col].max() > 2:   # e.g. 53.2, 25.1, etc.
            df[col]  df[col] / 100.0

    # We don't get FTAr from this endpoint, so set to 0 for now
    df["FTAr"]  0.0

    return df

#  Build the final team_stats_df USED BY THE MODEL
raw_team_stats_df  fetch_team_advanced_stats_raw("2024-25")
team_stats_df  prepare_team_stats(raw_team_stats_df)

print("team_stats_df columns:")
print(team_stats_df.columns)

def run_daily_probs_for_date(
    game_date"12/04/2025",
    odds_dictNone,        # still optional (can be None)
    spreads_dictNone,     # still optional
    stats_dfNone,
    edge_threshold0.03,
    lam0.20,
    injury_dfNone,        # NEW: you can pass a pre-fetched injury table
):
    """
    Run the model for all games on a given date, WITH automatic injury adjustment.

    game_date: 'MM/DD/YYYY' string for NBA API
    odds_dict: optional { (home, away): (home_ml, away_ml) } or dict with 'home_ml','away_ml','home_spread'
    spreads_dict: optional { (home, away): home_spread }
    injury_df: optional ESPN injury DataFrame;  None, we fetch it.
    """
     stats_df is None:
        stats_df  team_stats_df

    #  Fetch injuries once  not given
     injury_df is None:
        try:
            injury_df  fetch_injury_report_espn()
        except Exception as e:
            print(f" Could not fetch ESPN injuries, running without injuries: {e}")
            injury_df  None

    games_df  fetch_games_for_date(game_date)
    rows  []

    for _, row in games_df.iterrows():
        home  row["HOME_TEAM_NAME"]
        away  row["AWAY_TEAM_NAME"]

        # ----- Injuries for this matchup -----
         injury_df is not None:
            home_injuries  build_injury_list_for_team_espn(home, injury_df)
            away_injuries  build_injury_list_for_team_espn(away, injury_df)
        else:
            home_injuries  []
            away_injuries  []

        # ----- Odds & spreads (optional) -----
        home_ml  away_ml  None
        home_spread  None

         odds_dict is not None and (home, away) in odds_dict:
            val  odds_dict[(home, away)]
             isinstance(val, dict):
                home_ml  val.get("home_ml", None)
                away_ml  val.get("away_ml", None)
                home_spread  val.get("home_spread", None)
            else:
                home_ml, away_ml  val

         spreads_dict is not None and (home, away) in spreads_dict:
            home_spread  spreads_dict[(home, away)]

        # ----- Core model with injuries -----
        prob_home, base_score, inj_adj, adj_score  model_game_prob(
            home_team_namehome,
            away_team_nameaway,
            home_injurieshome_injuries,
            away_injuriesaway_injuries,
            stats_dfstats_df,
            lamlam,
        )

        model_spread_home  score_to_spread(adj_score)

        record  {
            "home": home,
            "away": away,
            "model_home_prob": prob_home,
            "base_score": base_score,
            "inj_adj": inj_adj,
            "adj_score": adj_score,
            "model_spread_home": model_spread_home,
        }

        # ----- Moneyline edges -----
         home_ml is not None and away_ml is not None:
            home_imp_raw  american_to_implied_prob(home_ml)
            away_imp_raw  american_to_implied_prob(away_ml)
            total  home_imp_raw + away_imp_raw
            home_imp  home_imp_raw / total
            away_imp  away_imp_raw / total

            edge_home  prob_home - home_imp
            edge_away  (1 - prob_home) - away_imp

            record.update({
                "home_ml": home_ml,
                "away_ml": away_ml,
                "market_home_prob": home_imp,
                "edge_home": edge_home,
                "edge_away": edge_away,
            })

        # ----- Spread edge -----
         home_spread is not None:
            spread_edge  model_spread_home - home_spread
            record.update({
                "home_spread": home_spread,
                "spread_edge_home": spread_edge,
            })

        rows.append(record)

    df  pd.DataFrame(rows)
     "edge_home" in df.columns:
        df["abs_edge_home"]  df["edge_home"].abs()
        df  df.sort_values("abs_edge_home", ascendingFalse).reset_index(dropTrue)

    return df

def fetch_team_advanced_stats(season"2024-25"):
    data  leaguedashteamstats.LeagueDashTeamStats(
        seasonseason,
        season_type_all_star"Regular Season",
        per_mode_detailed"PerGame",
        measure_type_detailed_defense"Advanced"
    )
    return data.get_data_frames()[0]

team_stats_df  fetch_team_advanced_stats("2024-25")

team_stats_df.head()

from nba_api.stats.endpoints import ScoreboardV2

def fetch_games_for_date(game_date"12/03/2025"):
    """
    game_date format: 'MM/DD/YYYY'
    Returns a DataFrame with home/away team names for that date.
    """
    sb  ScoreboardV2(
        game_dategame_date,
        league_id"00",
        day_offset0
    )

    games_df  sb.get_data_frames()[0]  # 'GameHeader'

    # Map TEAM_ID -> TEAM_NAME from your existing team_stats_df
    id_to_name  dict(zip(team_stats_df["TEAM_ID"], team_stats_df["TEAM_NAME"]))

    games_df["HOME_TEAM_NAME"]  games_df["HOME_TEAM_ID"].map(id_to_name)
    games_df["AWAY_TEAM_NAME"]  games_df["VISITOR_TEAM_ID"].map(id_to_name)

    # Keep only needed columns
    games_df  games_df[["GAME_ID", "HOME_TEAM_NAME", "AWAY_TEAM_NAME"]]
    return games_df

def score_to_spread(score, points_per_logit1.3):
    """
    Convert model 'score' into a predicted point spread.
    Positive  home favorite by that many points (home -spread).

    points_per_logit controls how "strong" scores translate into spread.
    You were using ~1.3 before, so we keep that.
    """
    return score * points_per_logit

import numpy as np
import pandas as pd  #  not already imported

# Example: fill these with the TRUE lines from your book
spreads_today  {
    ("Philadelphia 76ers", "Golden State Warriors"): -3.5,  # Sixers -3.5
    ("Washington Wizards", "Boston Celtics"): +9.5,         # Wizards +9.5 (so home_spread  +9.5)
    ("Brooklyn Nets", "Utah Jazz"): -2.0,                   # Nets -2
    ("Toronto Raptors", "Los Angeles Lakers"): +1.5,        # Raptors +1.5
    ("New Orleans Pelicans", "Minnesota Timberwolves"): +3.0,
}

odds_today  {
    ("Philadelphia 76ers", "Golden State Warriors"): {
        "home_ml": -177,
        "away_ml": +132,
        "home_spread": -3.5,   # Sixers -3.5
    },
    ("Washington Wizards", "Boston Celtics"): {
        "home_ml": +300,
        "away_ml": -461,
        "home_spread": +9.5,   # Wizards +9.5
    },
    ("Brooklyn Nets", "Utah Jazz"): {
        "home_ml": -183,
        "away_ml": +137,
        "home_spread": +4.5,   # Nets +4.5
    },
    ("Toronto Raptors", "Los Angeles Lakers"): {
        "home_ml": +102,
        "away_ml": -135,
        "home_spread": +2.5,   # Raps +2.5
    },
    ("New Orleans Pelicans", "Minnesota Timberwolves"): {
        "home_ml": +380,
        "away_ml": -625,
        "home_spread": 11.5,   # Pels +11.5
    },
}

import numpy as np
import pandas as pd

def american_to_implied_prob(odds):
    odds  float(odds)
     odds < 0:
        return (-odds) / ((-odds) + 100.0)
    else:
        return 100.0 / (odds + 100.0)


def attach_odds_and_best_bets(
    df,
    odds_dict,
    ml_edge_threshold0.03,      # 3 percentage points
    spread_edge_threshold1.5    # 1.5 points of spread edge
):
    """
    df: your full_day_df (must have home, away, model_home_prob, model_spread_home)
    odds_dict: { (home, away): {"home_ml":..., "away_ml":..., "home_spread":...}, ... }
    """

    df  df.copy()

    # --- 1) Attach odds/spreads to each row ---
    def get_odds(row):
        key  (row["home"], row["away"])
        rec  odds_dict.get(key)
         rec is None:
            return pd.Series([np.nan, np.nan, np.nan],
                             index["home_ml", "away_ml", "home_spread"])
        return pd.Series(
            [rec.get("home_ml"), rec.get("away_ml"), rec.get("home_spread")],
            index["home_ml", "away_ml", "home_spread"],
        )

    odds_cols  df.apply(get_odds, axis1)
    df  pd.concat([df, odds_cols], axis1)

    # --- 2) Moneyline edges ---
    mask_ml  df["home_ml"].notna() & df["away_ml"].notna()

    df.loc[mask_ml, "home_imp_raw"]  df.loc[mask_ml, "home_ml"].astype(float).map(
        american_to_implied_prob
    )
    df.loc[mask_ml, "away_imp_raw"]  df.loc[mask_ml, "away_ml"].astype(float).map(
        american_to_implied_prob
    )

    df.loc[mask_ml, "total_imp"]  (
        df.loc[mask_ml, "home_imp_raw"] + df.loc[mask_ml, "away_imp_raw"]
    )

    df.loc[mask_ml, "market_home_prob"]  (
        df.loc[mask_ml, "home_imp_raw"] / df.loc[mask_ml, "total_imp"]
    )
    df.loc[mask_ml, "market_away_prob"]  (
        df.loc[mask_ml, "away_imp_raw"] / df.loc[mask_ml, "total_imp"]
    )

    df["edge_home"]  df["model_home_prob"] - df["market_home_prob"]
    df["edge_away"]  (1 - df["model_home_prob"]) - df["market_away_prob"]

    # --- 3) Spread edge ---
    df["spread_edge_home"]  df["model_spread_home"] - df["home_spread"]

    # --- 4) Pick BEST: ML vs spread ---
    def choose_best(row):
        #  Moneyline side 
        ml_side  "none"
        ml_edge_val  0.0

         pd.notna(row.get("edge_home")):
            eh  row["edge_home"]
            ea  row.get("edge_away", -eh)

             eh > ml_edge_threshold and eh > abs(ea):
                ml_side  "HOME_ML"
                ml_edge_val  eh
            el ea > ml_edge_threshold and ea > abs(eh):
                ml_side  "AWAY_ML"
                ml_edge_val  ea

        #  Spread side 
        spread_side  "none"
        spread_edge_val  0.0
        se  row.get("spread_edge_home")
        hs  row.get("home_spread")

         pd.notna(se) and pd.notna(hs):
             se > spread_edge_threshold:
                spread_side  "HOME_SPREAD"
                spread_edge_val  se
            el se < -spread_edge_threshold:
                spread_side  "AWAY_SPREAD"
                spread_edge_val  abs(se)

        #  Decide between ML vs SPREAD 
         ml_side  "none" and spread_side  "none":
            return "No clear edge"

        #  spread has bigger absolute edge than ML, choose spread
         spread_side  "none" and spread_edge_val > abs(ml_edge_val):
             spread_side  "HOME_SPREAD":
                # format home line
                 hs < 0:
                    line_str  f"home {hs:+}"       # e.g. -3.5
                el hs > 0:
                    line_str  f"home +{hs:.1f}"
                else:
                    line_str  "home pk"
                return f"BEST: HOME spread ({line_str})"
            else:
                away_handicap  -hs
                 away_handicap < 0:
                    line_str  f"away {away_handicap:+}"
                el away_handicap > 0:
                    line_str  f"away +{away_handicap:.1f}"
                else:
                    line_str  "away pk"
                return f"BEST: AWAY spread ({line_str})"

        # Otherwise, go with ML  its strong enough
         ml_side  "HOME_ML":
            return f"BEST: HOME ML ({row['home_ml']:+})"
        el ml_side  "AWAY_ML":
            return f"BEST: AWAY ML ({row['away_ml']:+})"
        else:
            return "No clear edge"

    df["best_bet"]  df.apply(choose_best, axis1)

    return df

import pandas as pd
from nba_api.stats.static import teams as nba_teams

# Map full team name -> NBA abbreviation (PHI, BOS, etc.)
NBA_TEAM_MAP  {
    t["full_name"]: t["abbreviation"]
    for t in nba_teams.get_teams()
}

def fetch_injury_report_espn():
    """
    Scrape ESPN NBA injuries page into a clean DataFrame:
    columns: Player, Team, Pos, Status, Injury
    """
    url  "https://www.espn.com/nba/injuries"
    tables  pd.read_html(url)

     not tables:
        raise RuntimeError("Could not find any tables on ESPN injuries page")

    # Keep tables that look like injury tables
    injury_tables  []
    for t in tables:
        cols_norm  [str(c).strip().lower() for c in t.columns]
         any("player" in c or "name" in c for c in cols_norm):
            injury_tables.append(t)

     not injury_tables:
        # fallback: use everything
        injury_tables  tables

    df  pd.concat(injury_tables, ignore_indexTrue)

    # Normalize column names
    df.columns  [str(c).strip().title() for c in df.columns]

    rename_map  {}
    for c in df.columns:
        lc  c.lower()
         "player" in lc or "name" in lc:
            rename_map[c]  "Player"
        el "team" in lc:
            rename_map[c]  "Team"
        el "pos" in lc or "position" in lc:
            rename_map[c]  "Pos"
        el "status" in lc:
            rename_map[c]  "Status"
        el "injury" in lc or "reason" in lc:
            rename_map[c]  "Injury"

    df  df.rename(columnsrename_map)

    keep  [c for c in ["Player", "Team", "Pos", "Status", "Injury"]  c in df.columns]
    df  df[keep].copy()

    return df

INJURY_ROLE_WEIGHTS  {
    "star": 3.0,
    "starter": 1.5,
    "rotation": 1.0,
    "bench": 0.5,
}

INJURY_STATUS_MULTIPLIER  {
    "out": 1.0,
    "doubtful": 0.75,
    "questionable": 0.5,
    "probable": 0.25,
}

# optional: your manual overrides for star/starter etc.
PLAYER_ROLES  {
    # "Giannis Antetokounmpo": "star",
    # "Joel Embiid": "star",
    # "Steph Curry": "star",
    # fill in over time  you want better accuracy
}

def guess_role(player_name, pos):
    """
    Use your manual PLAYER_ROLES first; fall back on position.
    """
     player_name in PLAYER_ROLES:
        return PLAYER_ROLES[player_name]

    pos  (pos or "").upper()
     pos in ["PG", "SG", "SF", "PF", "G", "F", "C"]:
        return "starter"
    return "rotation"

def status_to_mult(status):
     not isinstance(status, str):
        return 1.0
    s  status.lower()
    for key, mult in INJURY_STATUS_MULTIPLIER.items():
         key in s:
            return mult
    # default: treat as fully out
    return 1.0

from datetime import datetime, timedelta

def run_x_days_stats(
    num_days,
    start_dateNone,      # "YYYY-MM-DD"
    odds_by_dateNone,    # {"YYYY-MM-DD": odds_dict}
    spreads_by_dateNone, # {"YYYY-MM-DD": spreads_dict}
    edge_threshold0.03,
    lam0.20,
    stats_dfNone,
    injury_dfNone,       # NEW
):
     stats_df is None:
        stats_df  team_stats_df

    #  no injury_df passed, grab once now
     injury_df is None:
        try:
            injury_df  fetch_injury_report_espn()
        except Exception as e:
            print(f" Could not fetch ESPN injuries, running without injuries: {e}")
            injury_df  None

     start_date is None:
        current_date  datetime.today().date()
    else:
        current_date  datetime.strptime(start_date, "%Y-%m-%d").date()

    all_results  {}

    for i in range(num_days):
        day  current_date + timedelta(daysi)
        date_iso  day.strftime("Y-m-d")   # for dict keys
        date_nba  day.strftime("m/d/Y")   # for ScoreboardV2

        print("\n")
        print(f"Running stats for {date_iso}")
        print("")

        odds_dict  odds_by_date.get(date_iso)  odds_by_date else None
        spreads_dict  spreads_by_date.get(date_iso)  spreads_by_date else None

        try:
            df  run_daily_probs_for_date(
                game_datedate_nba,
                odds_dictodds_dict,
                spreads_dictspreads_dict,
                stats_dfstats_df,
                edge_thresholdedge_threshold,
                lamlam,
                injury_dfinjury_df,   # <-- HERE
            )
            all_results[date_iso]  df
            display(df)
        except Exception as e:
            print(f" Error running for {date_iso}: {e}")

    return all_results

def add_spread_recommendations(df, spreads_dict, threshold1.5):
    """
    df: your full_day_df with model_spread_home column.
    spreads_dict: {(home, away): home_spread}
    threshold: how many points of edge before we bet (e.g. 1.5).
    """
    df  df.copy()

    # Attach the Vegas spread for each game
    df["home_spread"]  df.apply(
        lambda r: spreads_dict.get((r["home"], r["away"]), np.nan),
        axis1
    )

    # Model edge vs book line
    df["spread_edge_home"]  df["model_spread_home"] - df["home_spread"]

    def pick_recommendation(row):
        hs  row["home_spread"]
        se  row["spread_edge_home"]

         pd.isna(hs) or pd.isna(se):
            return "No spread line"

        # Model thinks home should be more favored than book  bet home
         se > threshold:
            # Format line nicely: home -X or +X
             hs < 0:
                line_str  f"home {hs:+}"   # e.g. -3.5
            else:
                line_str  f"home +{hs:.1f}"  hs > 0 else "home pk"
            return f"Bet HOME spread ({line_str})"

        # Model thinks home should be less favored  bet away
        el se < -threshold:
            # For away, opposite sign of home_spread
            away_handicap  -hs
             away_handicap < 0:
                line_str  f"away {away_handicap:+}"
            else:
                line_str  f"away +{away_handicap:.1f}"  away_handicap > 0 else "away pk"
            return f"Bet AWAY spread ({line_str})"

        else:
            return "No clear spread edge"

    df["spread_recommendation"]  df.apply(pick_recommendation, axis1)

    return df

#  Apply it to todays results
full_day_with_spreads  add_spread_recommendations(full_day_df, spreads_today, threshold1.5)
full_day_with_spreads

full_day_df  run_daily_probs_for_date("12/04/2025")

odds_today  {
    ("Philadelphia 76ers", "Golden State Warriors"): {
        "home_ml": -120,
        "away_ml": +100,
        "home_spread": -2.5,   # Sixers -2.5
    },
    ("Washington Wizards", "Boston Celtics"): {
        "home_ml": +350,
        "away_ml": -450,
        "home_spread": +9.5,   # Wizards +9.5
    },
    ("Brooklyn Nets", "Utah Jazz"): {
        "home_ml": -130,
        "away_ml": +110,
        "home_spread": -4.5,   # Nets -4.5
    },
    ("Toronto Raptors", "Los Angeles Lakers"): {
        "home_ml": +105,
        "away_ml": -125,
        "home_spread": +2.5,   # Raps +2.5
    },
    ("New Orleans Pelicans", "Minnesota Timberwolves"): {
        "home_ml": +380,
        "away_ml": -625,
        "home_spread": +11.5,   # Pels +11.5
    },
}

import numpy as np
import pandas as pd

def american_to_implied_prob(odds):
    odds  float(odds)
     odds < 0:
        return (-odds) / ((-odds) + 100.0)
    else:
        return 100.0 / (odds + 100.0)


def attach_odds_and_best_bets(
    df,
    odds_dict,
    ml_edge_threshold0.03,     # 3% edge needed on ML
    spread_edge_threshold1.5   # 1.5 pts edge needed on spread
):
    """
    df: your full_day_df with columns:
         home, away, model_home_prob, model_spread_home
    odds_dict: {
        (home, away): {
            "home_ml": ...,
            "away_ml": ...,
            "home_spread": ...
        },
        ...
    }
    """

    df  df.copy()

    # --- 1) Attach odds/spreads to each game ---
    def get_odds(row):
        key  (row["home"], row["away"])
        rec  odds_dict.get(key)
         rec is None:
            return pd.Series([np.nan, np.nan, np.nan],
                             index["home_ml", "away_ml", "home_spread"])
        return pd.Series(
            [rec.get("home_ml"), rec.get("away_ml"), rec.get("home_spread")],
            index["home_ml", "away_ml", "home_spread"],
        )

    odds_cols  df.apply(get_odds, axis1)
    df  pd.concat([df, odds_cols], axis1)

    # --- 2) Moneyline edges (model vs market) ---
    mask_ml  df["home_ml"].notna() & df["away_ml"].notna()

    df.loc[mask_ml, "home_imp_raw"]  df.loc[mask_ml, "home_ml"].astype(float).map(
        american_to_implied_prob
    )
    df.loc[mask_ml, "away_imp_raw"]  df.loc[mask_ml, "away_ml"].astype(float).map(
        american_to_implied_prob
    )

    df.loc[mask_ml, "total_imp"]  (
        df.loc[mask_ml, "home_imp_raw"] + df.loc[mask_ml, "away_imp_raw"]
    )

    df.loc[mask_ml, "market_home_prob"]  (
        df.loc[mask_ml, "home_imp_raw"] / df.loc[mask_ml, "total_imp"]
    )
    df.loc[mask_ml, "market_away_prob"]  (
        df.loc[mask_ml, "away_imp_raw"] / df.loc[mask_ml, "total_imp"]
    )

    df["edge_home"]  df["model_home_prob"] - df["market_home_prob"]
    df["edge_away"]  (1 - df["model_home_prob"]) - df["market_away_prob"]

    # --- 3) Spread edge (model vs line) ---
    df["spread_edge_home"]  df["model_spread_home"] - df["home_spread"]

    # --- 4) Decide best bet (ML vs spread) ---
    def choose_best(row):
        #  Moneyline side 
        ml_side  "none"
        ml_edge_val  0.0

        eh  row.get("edge_home")
        ea  row.get("edge_away")

         pd.notna(eh) and pd.notna(ea):
             eh > ml_edge_threshold and eh > abs(ea):
                ml_side  "HOME_ML"
                ml_edge_val  eh
            el ea > ml_edge_threshold and ea > abs(eh):
                ml_side  "AWAY_ML"
                ml_edge_val  ea

        #  Spread side 
        spread_side  "none"
        spread_edge_val  0.0
        se  row.get("spread_edge_home")
        hs  row.get("home_spread")

         pd.notna(se) and pd.notna(hs):
             se > spread_edge_threshold:
                spread_side  "HOME_SPREAD"
                spread_edge_val  se
            el se < -spread_edge_threshold:
                spread_side  "AWAY_SPREAD"
                spread_edge_val  abs(se)  # use absolute for comparison

        #  Decide between ML vs SPREAD 
         ml_side  "none" and spread_side  "none":
            return "No clear edge"

        #  spread has bigger edge than ML, choose spread
         spread_side  "none" and spread_edge_val > abs(ml_edge_val):
             spread_side  "HOME_SPREAD":
                # pretty-print home line
                 hs < 0:
                    line_str  f"home {hs:+}"     # e.g. -3.5
                el hs > 0:
                    line_str  f"home +{hs:.1f}"  # e.g. +3.0
                else:
                    line_str  "home pk"
                return f"BEST: HOME spread ({line_str})"
            else:
                # away spread is the opposite of home_spread
                away_handicap  -hs
                 away_handicap < 0:
                    line_str  f"away {away_handicap:+}"
                el away_handicap > 0:
                    line_str  f"away +{away_handicap:.1f}"
                else:
                    line_str  "away pk"
                return f"BEST: AWAY spread ({line_str})"

        # Otherwise go with ML
         ml_side  "HOME_ML":
            return f"BEST: HOME ML ({row['home_ml']:+})"
        el ml_side  "AWAY_ML":
            return f"BEST: AWAY ML ({row['away_ml']:+})"
        else:
            return "No clear edge"

    df["best_bet"]  df.apply(choose_best, axis1)

    return df

injury_df  fetch_injury_report_espn()

results  run_x_days_stats(
    3,
    start_date"2025-12-04",
    odds_by_dateNone,
    spreads_by_dateNone,
    injury_dfinjury_df,
)

full_day_df  run_daily_probs_for_date("12/04/2025")
full_day_df

full_day_with_bets  attach_odds_and_best_bets(full_day_df, odds_today)
full_day_with_bets[[
    "home", "away",
    "home_ml", "away_ml", "home_spread",
    "model_home_prob", "model_spread_home",
    "edge_home", "edge_away", "spread_edge_home",
    "best_bet"
]]

full_day_with_bets  attach_odds_and_best_bets(full_day_df, odds_today)

full_day_with_bets[[
    "home", "away",
    "home_ml", "away_ml", "home_spread",
    "model_home_prob", "model_spread_home",
    "edge_home", "edge_away", "spread_edge_home",
    "best_bet"
    def main():
    #  your code is currently top-level (not inside a function),
    # you can move it into here over time.
    # For now,  everything is already at top-level, you can skip this.
    pass

 __name__  "__main__":
    main()
]]
